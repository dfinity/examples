// This is an experimental feature to generate Rust binding from Candid.
// You may want to manually adjust some of the types.
use ic_cdk::export::candid::{self, CandidType, Deserialize};
use ic_cdk::api::call::CallResult;

#[derive(CandidType, Deserialize)]
struct NeuronId { id: u64 }

#[derive(CandidType, Deserialize)]
struct Followees { followees: Vec<NeuronId> }

#[derive(CandidType, Deserialize)]
struct KnownNeuronData { name: String, description: Option<String> }

#[derive(CandidType, Deserialize)]
struct KnownNeuron {
  id: Option<NeuronId>,
  known_neuron_data: Option<KnownNeuronData>,
}

#[derive(CandidType, Deserialize)]
struct FulfillSubnetRentalRequest {
  user: Option<candid::Principal>,
  replica_version_id: Option<String>,
  node_ids: Option<Vec<candid::Principal>>,
}

#[derive(CandidType, Deserialize)]
struct Spawn {
  percentage_to_spawn: Option<u32>,
  new_controller: Option<candid::Principal>,
  nonce: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct Split { amount_e8s: u64 }

#[derive(CandidType, Deserialize)]
struct Follow { topic: i32, followees: Vec<NeuronId> }

#[derive(CandidType, Deserialize)]
struct AccountIdentifier { hash: Vec<u8> }

#[derive(CandidType, Deserialize)]
struct Account { owner: Option<candid::Principal>, subaccount: Option<Vec<u8>> }

#[derive(CandidType, Deserialize)]
struct DisburseMaturity {
  to_account_identifier: Option<AccountIdentifier>,
  to_account: Option<Account>,
  percentage_to_disburse: u32,
}

#[derive(CandidType, Deserialize)]
struct RefreshVotingPower {}

#[derive(CandidType, Deserialize)]
struct ClaimOrRefreshNeuronFromAccount {
  controller: Option<candid::Principal>,
  memo: u64,
}

#[derive(CandidType, Deserialize)]
enum By {
  NeuronIdOrSubaccount{},
  MemoAndController(ClaimOrRefreshNeuronFromAccount),
  Memo(u64),
}

#[derive(CandidType, Deserialize)]
struct ClaimOrRefresh { by: Option<By> }

#[derive(CandidType, Deserialize)]
struct RemoveHotKey { hot_key_to_remove: Option<candid::Principal> }

#[derive(CandidType, Deserialize)]
struct AddHotKey { new_hot_key: Option<candid::Principal> }

#[derive(CandidType, Deserialize)]
struct ChangeAutoStakeMaturity {
  requested_setting_for_auto_stake_maturity: bool,
}

#[derive(CandidType, Deserialize)]
struct IncreaseDissolveDelay { additional_dissolve_delay_seconds: u32 }

#[derive(CandidType, Deserialize)]
struct SetVisibility { visibility: Option<i32> }

#[derive(CandidType, Deserialize)]
struct SetDissolveTimestamp { dissolve_timestamp_seconds: u64 }

#[derive(CandidType, Deserialize)]
enum Operation {
  RemoveHotKey(RemoveHotKey),
  AddHotKey(AddHotKey),
  ChangeAutoStakeMaturity(ChangeAutoStakeMaturity),
  StopDissolving{},
  StartDissolving{},
  IncreaseDissolveDelay(IncreaseDissolveDelay),
  SetVisibility(SetVisibility),
  JoinCommunityFund{},
  LeaveCommunityFund{},
  SetDissolveTimestamp(SetDissolveTimestamp),
}

#[derive(CandidType, Deserialize)]
struct Configure { operation: Option<Operation> }

#[derive(CandidType, Deserialize)]
struct ProposalId { id: u64 }

#[derive(CandidType, Deserialize)]
struct RegisterVote { vote: i32, proposal: Option<ProposalId> }

#[derive(CandidType, Deserialize)]
struct Merge { source_neuron_id: Option<NeuronId> }

#[derive(CandidType, Deserialize)]
struct DisburseToNeuron {
  dissolve_delay_seconds: u64,
  kyc_verified: bool,
  amount_e8s: u64,
  new_controller: Option<candid::Principal>,
  nonce: u64,
}

#[derive(CandidType, Deserialize)]
struct FolloweesForTopic {
  topic: Option<i32>,
  followees: Option<Vec<NeuronId>>,
}

#[derive(CandidType, Deserialize)]
struct SetFollowing { topic_following: Option<Vec<FolloweesForTopic>> }

#[derive(CandidType, Deserialize)]
struct StakeMaturity { percentage_to_stake: Option<u32> }

#[derive(CandidType, Deserialize)]
struct MergeMaturity { percentage_to_merge: u32 }

#[derive(CandidType, Deserialize)]
struct Amount { e8s: u64 }

#[derive(CandidType, Deserialize)]
struct Disburse {
  to_account: Option<AccountIdentifier>,
  amount: Option<Amount>,
}

#[derive(CandidType, Deserialize)]
enum Command {
  Spawn(Spawn),
  Split(Split),
  Follow(Follow),
  DisburseMaturity(DisburseMaturity),
  RefreshVotingPower(RefreshVotingPower),
  ClaimOrRefresh(ClaimOrRefresh),
  Configure(Configure),
  RegisterVote(RegisterVote),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SetFollowing(SetFollowing),
  MakeProposal(Box<Proposal>),
  StakeMaturity(StakeMaturity),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}

#[derive(CandidType, Deserialize)]
enum NeuronIdOrSubaccount { Subaccount(Vec<u8>), NeuronId(NeuronId) }

#[derive(CandidType, Deserialize)]
struct ManageNeuron {
  id: Option<NeuronId>,
  command: Option<Command>,
  neuron_id_or_subaccount: Option<NeuronIdOrSubaccount>,
}

#[derive(CandidType, Deserialize)]
struct Controllers { controllers: Vec<candid::Principal> }

#[derive(CandidType, Deserialize)]
struct CanisterSettings {
  freezing_threshold: Option<u64>,
  wasm_memory_threshold: Option<u64>,
  controllers: Option<Controllers>,
  log_visibility: Option<i32>,
  wasm_memory_limit: Option<u64>,
  memory_allocation: Option<u64>,
  compute_allocation: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct UpdateCanisterSettings {
  canister_id: Option<candid::Principal>,
  settings: Option<CanisterSettings>,
}

#[derive(CandidType, Deserialize)]
struct InstallCode {
  skip_stopping_before_installing: Option<bool>,
  wasm_module_hash: Option<Vec<u8>>,
  canister_id: Option<candid::Principal>,
  arg_hash: Option<Vec<u8>>,
  install_mode: Option<i32>,
}

#[derive(CandidType, Deserialize)]
struct StopOrStartCanister {
  action: Option<i32>,
  canister_id: Option<candid::Principal>,
}

#[derive(CandidType, Deserialize)]
struct Percentage { basis_points: Option<u64> }

#[derive(CandidType, Deserialize)]
struct Duration { seconds: Option<u64> }

#[derive(CandidType, Deserialize)]
struct Tokens { e8s: Option<u64> }

#[derive(CandidType, Deserialize)]
struct VotingRewardParameters {
  reward_rate_transition_duration: Option<Duration>,
  initial_reward_rate: Option<Percentage>,
  final_reward_rate: Option<Percentage>,
}

#[derive(CandidType, Deserialize)]
struct GovernanceParameters {
  neuron_maximum_dissolve_delay_bonus: Option<Percentage>,
  neuron_maximum_age_for_age_bonus: Option<Duration>,
  neuron_maximum_dissolve_delay: Option<Duration>,
  neuron_minimum_dissolve_delay_to_vote: Option<Duration>,
  neuron_maximum_age_bonus: Option<Percentage>,
  neuron_minimum_stake: Option<Tokens>,
  proposal_wait_for_quiet_deadline_increase: Option<Duration>,
  proposal_initial_voting_period: Option<Duration>,
  proposal_rejection_fee: Option<Tokens>,
  voting_reward_parameters: Option<VotingRewardParameters>,
}

#[derive(CandidType, Deserialize)]
struct Image { base64_encoding: Option<String> }

#[derive(CandidType, Deserialize)]
struct LedgerParameters {
  transaction_fee: Option<Tokens>,
  token_symbol: Option<String>,
  token_logo: Option<Image>,
  token_name: Option<String>,
}

#[derive(CandidType, Deserialize)]
struct Canister { id: Option<candid::Principal> }

#[derive(CandidType, Deserialize)]
struct NeuronBasketConstructionParameters {
  dissolve_delay_interval: Option<Duration>,
  count: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct GlobalTimeOfDay { seconds_after_utc_midnight: Option<u64> }

#[derive(CandidType, Deserialize)]
struct Countries { iso_codes: Vec<String> }

#[derive(CandidType, Deserialize)]
struct SwapParameters {
  minimum_participants: Option<u64>,
  neurons_fund_participation: Option<bool>,
  duration: Option<Duration>,
  neuron_basket_construction_parameters: Option<
    NeuronBasketConstructionParameters
  >,
  confirmation_text: Option<String>,
  maximum_participant_icp: Option<Tokens>,
  minimum_icp: Option<Tokens>,
  minimum_direct_participation_icp: Option<Tokens>,
  minimum_participant_icp: Option<Tokens>,
  start_time: Option<GlobalTimeOfDay>,
  maximum_direct_participation_icp: Option<Tokens>,
  maximum_icp: Option<Tokens>,
  neurons_fund_investment_icp: Option<Tokens>,
  restricted_countries: Option<Countries>,
}

#[derive(CandidType, Deserialize)]
struct SwapDistribution { total: Option<Tokens> }

#[derive(CandidType, Deserialize)]
struct NeuronDistribution {
  controller: Option<candid::Principal>,
  dissolve_delay: Option<Duration>,
  memo: Option<u64>,
  vesting_period: Option<Duration>,
  stake: Option<Tokens>,
}

#[derive(CandidType, Deserialize)]
struct DeveloperDistribution { developer_neurons: Vec<NeuronDistribution> }

#[derive(CandidType, Deserialize)]
struct InitialTokenDistribution {
  treasury_distribution: Option<SwapDistribution>,
  developer_distribution: Option<DeveloperDistribution>,
  swap_distribution: Option<SwapDistribution>,
}

#[derive(CandidType, Deserialize)]
struct CreateServiceNervousSystem {
  url: Option<String>,
  governance_parameters: Option<GovernanceParameters>,
  fallback_controller_principal_ids: Vec<candid::Principal>,
  logo: Option<Image>,
  name: Option<String>,
  ledger_parameters: Option<LedgerParameters>,
  description: Option<String>,
  dapp_canisters: Vec<Canister>,
  swap_parameters: Option<SwapParameters>,
  initial_token_distribution: Option<InitialTokenDistribution>,
}

#[derive(CandidType, Deserialize)]
struct ExecuteNnsFunction { nns_function: i32, payload: Vec<u8> }

#[derive(CandidType, Deserialize)]
struct NodeProvider {
  id: Option<candid::Principal>,
  reward_account: Option<AccountIdentifier>,
}

#[derive(CandidType, Deserialize)]
struct RewardToNeuron { dissolve_delay_seconds: u64 }

#[derive(CandidType, Deserialize)]
struct RewardToAccount { to_account: Option<AccountIdentifier> }

#[derive(CandidType, Deserialize)]
enum RewardMode {
  RewardToNeuron(RewardToNeuron),
  RewardToAccount(RewardToAccount),
}

#[derive(CandidType, Deserialize)]
struct RewardNodeProvider {
  node_provider: Option<NodeProvider>,
  reward_mode: Option<RewardMode>,
  amount_e8s: u64,
}

#[derive(CandidType, Deserialize)]
struct NeuronBasketConstructionParameters_1 {
  dissolve_delay_interval_seconds: u64,
  count: u64,
}

#[derive(CandidType, Deserialize)]
struct Params {
  min_participant_icp_e8s: u64,
  neuron_basket_construction_parameters: Option<
    NeuronBasketConstructionParameters_1
  >,
  max_icp_e8s: u64,
  swap_due_timestamp_seconds: u64,
  min_participants: u32,
  sns_token_e8s: u64,
  sale_delay_seconds: Option<u64>,
  max_participant_icp_e8s: u64,
  min_direct_participation_icp_e8s: Option<u64>,
  min_icp_e8s: u64,
  max_direct_participation_icp_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct OpenSnsTokenSwap {
  community_fund_investment_e8s: Option<u64>,
  target_swap_canister_id: Option<candid::Principal>,
  params: Option<Params>,
}

#[derive(CandidType, Deserialize)]
struct TimeWindow { start_timestamp_seconds: u64, end_timestamp_seconds: u64 }

#[derive(CandidType, Deserialize)]
struct SetOpenTimeWindowRequest { open_time_window: Option<TimeWindow> }

#[derive(CandidType, Deserialize)]
struct SetSnsTokenSwapOpenTimeWindow {
  request: Option<SetOpenTimeWindowRequest>,
  swap_canister_id: Option<candid::Principal>,
}

#[derive(CandidType, Deserialize)]
struct SetDefaultFollowees { default_followees: Vec<(i32,Followees,)> }

#[derive(CandidType, Deserialize)]
struct RewardNodeProviders {
  use_registry_derived_rewards: Option<bool>,
  rewards: Vec<RewardNodeProvider>,
}

#[derive(CandidType, Deserialize)]
struct VotingPowerEconomics {
  start_reducing_voting_power_after_seconds: Option<u64>,
  neuron_minimum_dissolve_delay_to_vote_seconds: Option<u64>,
  clear_following_after_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct Decimal { human_readable: Option<String> }

#[derive(CandidType, Deserialize)]
struct NeuronsFundMatchedFundingCurveCoefficients {
  contribution_threshold_xdr: Option<Decimal>,
  one_third_participation_milestone_xdr: Option<Decimal>,
  full_participation_milestone_xdr: Option<Decimal>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundEconomics {
  maximum_icp_xdr_rate: Option<Percentage>,
  neurons_fund_matched_funding_curve_coefficients: Option<
    NeuronsFundMatchedFundingCurveCoefficients
  >,
  max_theoretical_neurons_fund_participation_amount_xdr: Option<Decimal>,
  minimum_icp_xdr_rate: Option<Percentage>,
}

#[derive(CandidType, Deserialize)]
struct NetworkEconomics {
  neuron_minimum_stake_e8s: u64,
  voting_power_economics: Option<VotingPowerEconomics>,
  max_proposals_to_keep_per_topic: u32,
  neuron_management_fee_per_proposal_e8s: u64,
  reject_cost_e8s: u64,
  transaction_fee_e8s: u64,
  neuron_spawn_dissolve_delay_seconds: u64,
  minimum_icp_xdr_rate: u64,
  maximum_node_provider_rewards_e8s: u64,
  neurons_fund_economics: Option<NeuronsFundEconomics>,
}

#[derive(CandidType, Deserialize)]
struct Principals { principals: Vec<candid::Principal> }

#[derive(CandidType, Deserialize)]
enum Change { ToRemove(NodeProvider), ToAdd(NodeProvider) }

#[derive(CandidType, Deserialize)]
struct AddOrRemoveNodeProvider { change: Option<Change> }

#[derive(CandidType, Deserialize)]
struct Motion { motion_text: String }

#[derive(CandidType, Deserialize)]
enum Action {
  RegisterKnownNeuron(KnownNeuron),
  FulfillSubnetRentalRequest(FulfillSubnetRentalRequest),
  ManageNeuron(ManageNeuron),
  UpdateCanisterSettings(UpdateCanisterSettings),
  InstallCode(InstallCode),
  StopOrStartCanister(StopOrStartCanister),
  CreateServiceNervousSystem(CreateServiceNervousSystem),
  ExecuteNnsFunction(ExecuteNnsFunction),
  RewardNodeProvider(RewardNodeProvider),
  OpenSnsTokenSwap(OpenSnsTokenSwap),
  SetSnsTokenSwapOpenTimeWindow(SetSnsTokenSwapOpenTimeWindow),
  SetDefaultFollowees(SetDefaultFollowees),
  RewardNodeProviders(RewardNodeProviders),
  ManageNetworkEconomics(NetworkEconomics),
  ApproveGenesisKyc(Principals),
  AddOrRemoveNodeProvider(AddOrRemoveNodeProvider),
  Motion(Motion),
}

#[derive(CandidType, Deserialize)]
struct Proposal {
  url: String,
  title: Option<String>,
  action: Option<Action>,
  summary: String,
}

#[derive(CandidType, Deserialize)]
struct MakingSnsProposal {
  proposal: Option<Box<Proposal>>,
  caller: Option<candid::Principal>,
  proposer_id: Option<NeuronId>,
}

#[derive(CandidType, Deserialize)]
struct XdrConversionRate {
  xdr_permyriad_per_icp: Option<u64>,
  timestamp_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct MonthlyNodeProviderRewards {
  minimum_xdr_permyriad_per_icp: Option<u64>,
  registry_version: Option<u64>,
  node_providers: Vec<NodeProvider>,
  timestamp: u64,
  rewards: Vec<RewardNodeProvider>,
  xdr_conversion_rate: Option<XdrConversionRate>,
  maximum_node_provider_rewards_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct NeuronSubsetMetrics {
  total_maturity_e8s_equivalent: Option<u64>,
  maturity_e8s_equivalent_buckets: Vec<(u64,u64,)>,
  voting_power_buckets: Vec<(u64,u64,)>,
  total_staked_e8s: Option<u64>,
  count: Option<u64>,
  deciding_voting_power_buckets: Vec<(u64,u64,)>,
  total_staked_maturity_e8s_equivalent: Option<u64>,
  total_potential_voting_power: Option<u64>,
  total_deciding_voting_power: Option<u64>,
  staked_maturity_e8s_equivalent_buckets: Vec<(u64,u64,)>,
  staked_e8s_buckets: Vec<(u64,u64,)>,
  total_voting_power: Option<u64>,
  potential_voting_power_buckets: Vec<(u64,u64,)>,
  count_buckets: Vec<(u64,u64,)>,
}

#[derive(CandidType, Deserialize)]
struct GovernanceCachedMetrics {
  total_maturity_e8s_equivalent: u64,
  not_dissolving_neurons_e8s_buckets: Vec<(u64,f64,)>,
  dissolving_neurons_staked_maturity_e8s_equivalent_sum: u64,
  garbage_collectable_neurons_count: u64,
  dissolving_neurons_staked_maturity_e8s_equivalent_buckets: Vec<(u64,f64,)>,
  neurons_with_invalid_stake_count: u64,
  not_dissolving_neurons_count_buckets: Vec<(u64,u64,)>,
  ect_neuron_count: u64,
  total_supply_icp: u64,
  neurons_with_less_than_6_months_dissolve_delay_count: u64,
  dissolved_neurons_count: u64,
  community_fund_total_maturity_e8s_equivalent: u64,
  total_staked_e8s_seed: u64,
  total_staked_maturity_e8s_equivalent_ect: u64,
  total_staked_e8s: u64,
  fully_lost_voting_power_neuron_subset_metrics: Option<NeuronSubsetMetrics>,
  not_dissolving_neurons_count: u64,
  total_locked_e8s: u64,
  neurons_fund_total_active_neurons: u64,
  total_voting_power_non_self_authenticating_controller: Option<u64>,
  total_staked_maturity_e8s_equivalent: u64,
  not_dissolving_neurons_e8s_buckets_ect: Vec<(u64,f64,)>,
  spawning_neurons_count: u64,
  declining_voting_power_neuron_subset_metrics: Option<NeuronSubsetMetrics>,
  total_staked_e8s_ect: u64,
  not_dissolving_neurons_staked_maturity_e8s_equivalent_sum: u64,
  dissolved_neurons_e8s: u64,
  total_staked_e8s_non_self_authenticating_controller: Option<u64>,
  dissolving_neurons_e8s_buckets_seed: Vec<(u64,f64,)>,
  neurons_with_less_than_6_months_dissolve_delay_e8s: u64,
  not_dissolving_neurons_staked_maturity_e8s_equivalent_buckets: Vec<
    (u64,f64,)
  >,
  dissolving_neurons_count_buckets: Vec<(u64,u64,)>,
  dissolving_neurons_e8s_buckets_ect: Vec<(u64,f64,)>,
  non_self_authenticating_controller_neuron_subset_metrics: Option<
    NeuronSubsetMetrics
  >,
  dissolving_neurons_count: u64,
  dissolving_neurons_e8s_buckets: Vec<(u64,f64,)>,
  total_staked_maturity_e8s_equivalent_seed: u64,
  community_fund_total_staked_e8s: u64,
  not_dissolving_neurons_e8s_buckets_seed: Vec<(u64,f64,)>,
  public_neuron_subset_metrics: Option<NeuronSubsetMetrics>,
  timestamp_seconds: u64,
  seed_neuron_count: u64,
}

#[derive(CandidType, Deserialize)]
struct RestoreAgingNeuronGroup {
  count: Option<u64>,
  previous_total_stake_e8s: Option<u64>,
  current_total_stake_e8s: Option<u64>,
  group_type: i32,
}

#[derive(CandidType, Deserialize)]
struct RestoreAgingSummary {
  groups: Vec<RestoreAgingNeuronGroup>,
  timestamp_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct RewardEvent {
  rounds_since_last_distribution: Option<u64>,
  day_after_genesis: u64,
  actual_timestamp_seconds: u64,
  total_available_e8s_equivalent: u64,
  latest_round_available_e8s_equivalent: Option<u64>,
  distributed_e8s_equivalent: u64,
  settled_proposals: Vec<ProposalId>,
}

#[derive(CandidType, Deserialize)]
struct NeuronStakeTransfer {
  to_subaccount: Vec<u8>,
  neuron_stake_e8s: u64,
  from: Option<candid::Principal>,
  memo: u64,
  from_subaccount: Vec<u8>,
  transfer_timestamp: u64,
  block_height: u64,
}

#[derive(CandidType, Deserialize)]
struct GovernanceError { error_message: String, error_type: i32 }

#[derive(CandidType, Deserialize)]
struct Ballot { vote: i32, voting_power: u64 }

#[derive(CandidType, Deserialize)]
struct SwapParticipationLimits {
  min_participant_icp_e8s: Option<u64>,
  max_participant_icp_e8s: Option<u64>,
  min_direct_participation_icp_e8s: Option<u64>,
  max_direct_participation_icp_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundNeuronPortion {
  controller: Option<candid::Principal>,
  hotkeys: Vec<candid::Principal>,
  is_capped: Option<bool>,
  maturity_equivalent_icp_e8s: Option<u64>,
  nns_neuron_id: Option<NeuronId>,
  amount_icp_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundSnapshot {
  neurons_fund_neuron_portions: Vec<NeuronsFundNeuronPortion>,
}

#[derive(CandidType, Deserialize)]
struct IdealMatchedParticipationFunction {
  serialized_representation: Option<String>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundParticipation {
  total_maturity_equivalent_icp_e8s: Option<u64>,
  intended_neurons_fund_participation_icp_e8s: Option<u64>,
  direct_participation_icp_e8s: Option<u64>,
  swap_participation_limits: Option<SwapParticipationLimits>,
  max_neurons_fund_swap_participation_icp_e8s: Option<u64>,
  neurons_fund_reserves: Option<NeuronsFundSnapshot>,
  ideal_matched_participation_function: Option<
    IdealMatchedParticipationFunction
  >,
  allocated_neurons_fund_participation_icp_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundData {
  final_neurons_fund_participation: Option<NeuronsFundParticipation>,
  initial_neurons_fund_participation: Option<NeuronsFundParticipation>,
  neurons_fund_refunds: Option<NeuronsFundSnapshot>,
}

#[derive(CandidType, Deserialize)]
struct CanisterStatusResultV2 {
  status: Option<i32>,
  freezing_threshold: Option<u64>,
  controllers: Vec<candid::Principal>,
  memory_size: Option<u64>,
  cycles: Option<u64>,
  idle_cycles_burned_per_day: Option<u64>,
  module_hash: Vec<u8>,
}

#[derive(CandidType, Deserialize)]
struct CanisterSummary {
  status: Option<CanisterStatusResultV2>,
  canister_id: Option<candid::Principal>,
}

#[derive(CandidType, Deserialize)]
struct SwapBackgroundInformation {
  ledger_index_canister_summary: Option<CanisterSummary>,
  fallback_controller_principal_ids: Vec<candid::Principal>,
  ledger_archive_canister_summaries: Vec<CanisterSummary>,
  ledger_canister_summary: Option<CanisterSummary>,
  swap_canister_summary: Option<CanisterSummary>,
  governance_canister_summary: Option<CanisterSummary>,
  root_canister_summary: Option<CanisterSummary>,
  dapp_canister_summaries: Vec<CanisterSummary>,
}

#[derive(CandidType, Deserialize)]
struct DerivedProposalInformation {
  swap_background_information: Option<SwapBackgroundInformation>,
}

#[derive(CandidType, Deserialize)]
struct Tally { no: u64, yes: u64, total: u64, timestamp_seconds: u64 }

#[derive(CandidType, Deserialize)]
struct WaitForQuietState { current_deadline_timestamp_seconds: u64 }

#[derive(CandidType, Deserialize)]
struct ProposalData {
  id: Option<ProposalId>,
  topic: Option<i32>,
  failure_reason: Option<GovernanceError>,
  ballots: Vec<(u64,Ballot,)>,
  proposal_timestamp_seconds: u64,
  reward_event_round: u64,
  failed_timestamp_seconds: u64,
  neurons_fund_data: Option<NeuronsFundData>,
  reject_cost_e8s: u64,
  derived_proposal_information: Option<DerivedProposalInformation>,
  latest_tally: Option<Tally>,
  total_potential_voting_power: Option<u64>,
  sns_token_swap_lifecycle: Option<i32>,
  decided_timestamp_seconds: u64,
  proposal: Option<Box<Proposal>>,
  proposer: Option<NeuronId>,
  wait_for_quiet_state: Option<WaitForQuietState>,
  executed_timestamp_seconds: u64,
  original_total_community_fund_maturity_e8s_equivalent: Option<u64>,
}

#[derive(CandidType, Deserialize)]
enum Command_2 {
  Spawn(NeuronId),
  Split(Split),
  Configure(Configure),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SyncCommand{},
  ClaimOrRefreshNeuron(ClaimOrRefresh),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}

#[derive(CandidType, Deserialize)]
struct NeuronInFlightCommand { command: Option<Command_2>, timestamp: u64 }

#[derive(CandidType, Deserialize)]
struct BallotInfo { vote: i32, proposal_id: Option<ProposalId> }

#[derive(CandidType, Deserialize)]
struct MaturityDisbursement {
  account_identifier_to_disburse_to: Option<AccountIdentifier>,
  timestamp_of_disbursement_seconds: Option<u64>,
  amount_e8s: Option<u64>,
  account_to_disburse_to: Option<Account>,
  finalize_disbursement_timestamp_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
enum DissolveState {
  DissolveDelaySeconds(u64),
  WhenDissolvedTimestampSeconds(u64),
}

#[derive(CandidType, Deserialize)]
struct Neuron {
  id: Option<NeuronId>,
  staked_maturity_e8s_equivalent: Option<u64>,
  controller: Option<candid::Principal>,
  recent_ballots: Vec<BallotInfo>,
  voting_power_refreshed_timestamp_seconds: Option<u64>,
  kyc_verified: bool,
  potential_voting_power: Option<u64>,
  neuron_type: Option<i32>,
  not_for_profit: bool,
  maturity_e8s_equivalent: u64,
  deciding_voting_power: Option<u64>,
  cached_neuron_stake_e8s: u64,
  created_timestamp_seconds: u64,
  auto_stake_maturity: Option<bool>,
  aging_since_timestamp_seconds: u64,
  hot_keys: Vec<candid::Principal>,
  account: Vec<u8>,
  joined_community_fund_timestamp_seconds: Option<u64>,
  maturity_disbursements_in_progress: Option<Vec<MaturityDisbursement>>,
  dissolve_state: Option<DissolveState>,
  followees: Vec<(i32,Followees,)>,
  neuron_fees_e8s: u64,
  visibility: Option<i32>,
  transfer: Option<NeuronStakeTransfer>,
  known_neuron_data: Option<KnownNeuronData>,
  spawn_at_timestamp_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct Governance {
  default_followees: Vec<(i32,Followees,)>,
  making_sns_proposal: Option<MakingSnsProposal>,
  most_recent_monthly_node_provider_rewards: Option<MonthlyNodeProviderRewards>,
  maturity_modulation_last_updated_at_timestamp_seconds: Option<u64>,
  wait_for_quiet_threshold_seconds: u64,
  metrics: Option<GovernanceCachedMetrics>,
  neuron_management_voting_period_seconds: Option<u64>,
  node_providers: Vec<NodeProvider>,
  cached_daily_maturity_modulation_basis_points: Option<i32>,
  economics: Option<NetworkEconomics>,
  restore_aging_summary: Option<RestoreAgingSummary>,
  spawning_neurons: Option<bool>,
  latest_reward_event: Option<RewardEvent>,
  to_claim_transfers: Vec<NeuronStakeTransfer>,
  short_voting_period_seconds: u64,
  proposals: Vec<(u64,ProposalData,)>,
  xdr_conversion_rate: Option<XdrConversionRate>,
  in_flight_commands: Vec<(u64,NeuronInFlightCommand,)>,
  neurons: Vec<(u64,Neuron,)>,
  genesis_timestamp_seconds: u64,
}

#[derive(CandidType, Deserialize)]
enum Result { Ok, Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
enum Result_1 { Error(GovernanceError), NeuronId(NeuronId) }

#[derive(CandidType, Deserialize)]
struct ClaimOrRefreshNeuronFromAccountResponse { result: Option<Result_1> }

#[derive(CandidType, Deserialize)]
enum Result_2 { Ok(Neuron), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
enum Result_3 { Ok(GovernanceCachedMetrics), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
enum Result_4 { Ok(MonthlyNodeProviderRewards), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
struct NeuronInfo {
  dissolve_delay_seconds: u64,
  recent_ballots: Vec<BallotInfo>,
  voting_power_refreshed_timestamp_seconds: Option<u64>,
  potential_voting_power: Option<u64>,
  neuron_type: Option<i32>,
  deciding_voting_power: Option<u64>,
  created_timestamp_seconds: u64,
  state: i32,
  stake_e8s: u64,
  joined_community_fund_timestamp_seconds: Option<u64>,
  retrieved_at_timestamp_seconds: u64,
  visibility: Option<i32>,
  known_neuron_data: Option<KnownNeuronData>,
  voting_power: u64,
  age_seconds: u64,
}

#[derive(CandidType, Deserialize)]
enum Result_5 { Ok(NeuronInfo), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
struct GetNeuronsFundAuditInfoRequest { nns_proposal_id: Option<ProposalId> }

#[derive(CandidType, Deserialize)]
struct NeuronsFundAuditInfo {
  final_neurons_fund_participation: Option<NeuronsFundParticipation>,
  initial_neurons_fund_participation: Option<NeuronsFundParticipation>,
  neurons_fund_refunds: Option<NeuronsFundSnapshot>,
}

#[derive(CandidType, Deserialize)]
struct Ok { neurons_fund_audit_info: Option<NeuronsFundAuditInfo> }

#[derive(CandidType, Deserialize)]
enum Result_6 { Ok(Ok), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
struct GetNeuronsFundAuditInfoResponse { result: Option<Result_6> }

#[derive(CandidType, Deserialize)]
enum Result_7 { Ok(NodeProvider), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
struct ProposalInfo {
  id: Option<ProposalId>,
  status: i32,
  topic: i32,
  failure_reason: Option<GovernanceError>,
  ballots: Vec<(u64,Ballot,)>,
  proposal_timestamp_seconds: u64,
  reward_event_round: u64,
  deadline_timestamp_seconds: Option<u64>,
  failed_timestamp_seconds: u64,
  reject_cost_e8s: u64,
  derived_proposal_information: Option<DerivedProposalInformation>,
  latest_tally: Option<Tally>,
  total_potential_voting_power: Option<u64>,
  reward_status: i32,
  decided_timestamp_seconds: u64,
  proposal: Option<Box<Proposal>>,
  proposer: Option<NeuronId>,
  executed_timestamp_seconds: u64,
}

#[derive(CandidType, Deserialize)]
struct ListKnownNeuronsResponse { known_neurons: Vec<KnownNeuron> }

#[derive(CandidType, Deserialize)]
struct NeuronSubaccount { subaccount: Vec<u8> }

#[derive(CandidType, Deserialize)]
struct ListNeurons {
  page_size: Option<u64>,
  include_public_neurons_in_full_neurons: Option<bool>,
  neuron_ids: Vec<u64>,
  page_number: Option<u64>,
  include_empty_neurons_readable_by_caller: Option<bool>,
  neuron_subaccounts: Option<Vec<NeuronSubaccount>>,
  include_neurons_readable_by_caller: bool,
}

#[derive(CandidType, Deserialize)]
struct ListNeuronsResponse {
  neuron_infos: Vec<(u64,NeuronInfo,)>,
  full_neurons: Vec<Neuron>,
  total_pages_available: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct DateRangeFilter {
  start_timestamp_seconds: Option<u64>,
  end_timestamp_seconds: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct ListNodeProviderRewardsRequest { date_filter: Option<DateRangeFilter> }

#[derive(CandidType, Deserialize)]
struct ListNodeProviderRewardsResponse {
  rewards: Vec<MonthlyNodeProviderRewards>,
}

#[derive(CandidType, Deserialize)]
struct ListNodeProvidersResponse { node_providers: Vec<NodeProvider> }

#[derive(CandidType, Deserialize)]
struct ListProposalInfo {
  include_reward_status: Vec<i32>,
  omit_large_fields: Option<bool>,
  before_proposal: Option<ProposalId>,
  limit: u32,
  exclude_topic: Vec<i32>,
  include_all_manage_neuron_proposals: Option<bool>,
  include_status: Vec<i32>,
}

#[derive(CandidType, Deserialize)]
struct ListProposalInfoResponse { proposal_info: Vec<ProposalInfo> }

#[derive(CandidType, Deserialize)]
struct InstallCodeRequest {
  arg: Option<Vec<u8>>,
  wasm_module: Option<Vec<u8>>,
  skip_stopping_before_installing: Option<bool>,
  canister_id: Option<candid::Principal>,
  install_mode: Option<i32>,
}

#[derive(CandidType, Deserialize)]
enum ProposalActionRequest {
  RegisterKnownNeuron(KnownNeuron),
  FulfillSubnetRentalRequest(FulfillSubnetRentalRequest),
  ManageNeuron(Box<ManageNeuronRequest>),
  UpdateCanisterSettings(UpdateCanisterSettings),
  InstallCode(InstallCodeRequest),
  StopOrStartCanister(StopOrStartCanister),
  CreateServiceNervousSystem(CreateServiceNervousSystem),
  ExecuteNnsFunction(ExecuteNnsFunction),
  RewardNodeProvider(RewardNodeProvider),
  RewardNodeProviders(RewardNodeProviders),
  ManageNetworkEconomics(NetworkEconomics),
  ApproveGenesisKyc(Principals),
  AddOrRemoveNodeProvider(AddOrRemoveNodeProvider),
  Motion(Motion),
}

#[derive(CandidType, Deserialize)]
struct MakeProposalRequest {
  url: String,
  title: Option<String>,
  action: Option<ProposalActionRequest>,
  summary: String,
}

#[derive(CandidType, Deserialize)]
enum ManageNeuronCommandRequest {
  Spawn(Spawn),
  Split(Split),
  Follow(Follow),
  DisburseMaturity(DisburseMaturity),
  RefreshVotingPower(RefreshVotingPower),
  ClaimOrRefresh(ClaimOrRefresh),
  Configure(Configure),
  RegisterVote(RegisterVote),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SetFollowing(SetFollowing),
  MakeProposal(MakeProposalRequest),
  StakeMaturity(StakeMaturity),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}

#[derive(CandidType, Deserialize)]
struct ManageNeuronRequest {
  id: Option<NeuronId>,
  command: Option<ManageNeuronCommandRequest>,
  neuron_id_or_subaccount: Option<NeuronIdOrSubaccount>,
}

#[derive(CandidType, Deserialize)]
struct SpawnResponse { created_neuron_id: Option<NeuronId> }

#[derive(CandidType, Deserialize)]
struct DisburseMaturityResponse { amount_disbursed_e8s: Option<u64> }

#[derive(CandidType, Deserialize)]
struct RefreshVotingPowerResponse {}

#[derive(CandidType, Deserialize)]
struct ClaimOrRefreshResponse { refreshed_neuron_id: Option<NeuronId> }

#[derive(CandidType, Deserialize)]
struct MergeResponse {
  target_neuron: Option<Neuron>,
  source_neuron: Option<Neuron>,
  target_neuron_info: Option<NeuronInfo>,
  source_neuron_info: Option<NeuronInfo>,
}

#[derive(CandidType, Deserialize)]
struct SetFollowingResponse {}

#[derive(CandidType, Deserialize)]
struct MakeProposalResponse {
  message: Option<String>,
  proposal_id: Option<ProposalId>,
}

#[derive(CandidType, Deserialize)]
struct StakeMaturityResponse { maturity_e8s: u64, staked_maturity_e8s: u64 }

#[derive(CandidType, Deserialize)]
struct MergeMaturityResponse { merged_maturity_e8s: u64, new_stake_e8s: u64 }

#[derive(CandidType, Deserialize)]
struct DisburseResponse { transfer_block_height: u64 }

#[derive(CandidType, Deserialize)]
enum Command_1 {
  Error(GovernanceError),
  Spawn(SpawnResponse),
  Split(SpawnResponse),
  Follow{},
  DisburseMaturity(DisburseMaturityResponse),
  RefreshVotingPower(RefreshVotingPowerResponse),
  ClaimOrRefresh(ClaimOrRefreshResponse),
  Configure{},
  RegisterVote{},
  Merge(MergeResponse),
  DisburseToNeuron(SpawnResponse),
  SetFollowing(SetFollowingResponse),
  MakeProposal(MakeProposalResponse),
  StakeMaturity(StakeMaturityResponse),
  MergeMaturity(MergeMaturityResponse),
  Disburse(DisburseResponse),
}

#[derive(CandidType, Deserialize)]
struct ManageNeuronResponse { command: Option<Command_1> }

#[derive(CandidType, Deserialize)]
struct Committed {
  total_direct_contribution_icp_e8s: Option<u64>,
  total_neurons_fund_contribution_icp_e8s: Option<u64>,
  sns_governance_canister_id: Option<candid::Principal>,
}

#[derive(CandidType, Deserialize)]
enum Result_8 { Committed(Committed), Aborted{} }

#[derive(CandidType, Deserialize)]
struct SettleCommunityFundParticipation {
  result: Option<Result_8>,
  open_sns_token_swap_proposal_id: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct Committed_1 {
  total_direct_participation_icp_e8s: Option<u64>,
  total_neurons_fund_participation_icp_e8s: Option<u64>,
  sns_governance_canister_id: Option<candid::Principal>,
}

#[derive(CandidType, Deserialize)]
enum Result_9 { Committed(Committed_1), Aborted{} }

#[derive(CandidType, Deserialize)]
struct SettleNeuronsFundParticipationRequest {
  result: Option<Result_9>,
  nns_proposal_id: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct NeuronsFundNeuron {
  controller: Option<candid::Principal>,
  hotkeys: Option<Principals>,
  is_capped: Option<bool>,
  nns_neuron_id: Option<u64>,
  amount_icp_e8s: Option<u64>,
}

#[derive(CandidType, Deserialize)]
struct Ok_1 { neurons_fund_neuron_portions: Vec<NeuronsFundNeuron> }

#[derive(CandidType, Deserialize)]
enum Result_10 { Ok(Ok_1), Err(GovernanceError) }

#[derive(CandidType, Deserialize)]
struct SettleNeuronsFundParticipationResponse { result: Option<Result_10> }

#[derive(CandidType, Deserialize)]
struct UpdateNodeProvider { reward_account: Option<AccountIdentifier> }

struct SERVICE(candid::Principal);
impl SERVICE{
  pub async fn claim_gtc_neurons(
    &self,
    arg0: candid::Principal,
    arg1: Vec<NeuronId>,
  ) -> CallResult<(Result,)> {
    ic_cdk::call(self.0, "claim_gtc_neurons", (arg0,arg1,)).await
  }
  pub async fn claim_or_refresh_neuron_from_account(
    &self,
    arg0: ClaimOrRefreshNeuronFromAccount,
  ) -> CallResult<(ClaimOrRefreshNeuronFromAccountResponse,)> {
    ic_cdk::call(self.0, "claim_or_refresh_neuron_from_account", (arg0,)).await
  }
  pub async fn get_build_metadata(&self) -> CallResult<(String,)> {
    ic_cdk::call(self.0, "get_build_metadata", ()).await
  }
  pub async fn get_full_neuron(&self, arg0: u64) -> CallResult<(Result_2,)> {
    ic_cdk::call(self.0, "get_full_neuron", (arg0,)).await
  }
  pub async fn get_full_neuron_by_id_or_subaccount(
    &self,
    arg0: NeuronIdOrSubaccount,
  ) -> CallResult<(Result_2,)> {
    ic_cdk::call(self.0, "get_full_neuron_by_id_or_subaccount", (arg0,)).await
  }
  pub async fn get_latest_reward_event(&self) -> CallResult<(RewardEvent,)> {
    ic_cdk::call(self.0, "get_latest_reward_event", ()).await
  }
  pub async fn get_metrics(&self) -> CallResult<(Result_3,)> {
    ic_cdk::call(self.0, "get_metrics", ()).await
  }
  pub async fn get_monthly_node_provider_rewards(&self) -> CallResult<
    (Result_4,)
  > { ic_cdk::call(self.0, "get_monthly_node_provider_rewards", ()).await }
  pub async fn get_most_recent_monthly_node_provider_rewards(
    &self,
  ) -> CallResult<(Option<MonthlyNodeProviderRewards>,)> {
    ic_cdk::call(self.0, "get_most_recent_monthly_node_provider_rewards", ()).await
  }
  pub async fn get_network_economics_parameters(&self) -> CallResult<
    (NetworkEconomics,)
  > { ic_cdk::call(self.0, "get_network_economics_parameters", ()).await }
  pub async fn get_neuron_ids(&self) -> CallResult<(Vec<u64>,)> {
    ic_cdk::call(self.0, "get_neuron_ids", ()).await
  }
  pub async fn get_neuron_info(&self, arg0: u64) -> CallResult<(Result_5,)> {
    ic_cdk::call(self.0, "get_neuron_info", (arg0,)).await
  }
  pub async fn get_neuron_info_by_id_or_subaccount(
    &self,
    arg0: NeuronIdOrSubaccount,
  ) -> CallResult<(Result_5,)> {
    ic_cdk::call(self.0, "get_neuron_info_by_id_or_subaccount", (arg0,)).await
  }
  pub async fn get_neurons_fund_audit_info(
    &self,
    arg0: GetNeuronsFundAuditInfoRequest,
  ) -> CallResult<(GetNeuronsFundAuditInfoResponse,)> {
    ic_cdk::call(self.0, "get_neurons_fund_audit_info", (arg0,)).await
  }
  pub async fn get_node_provider_by_caller(&self, arg0: ()) -> CallResult<
    (Result_7,)
  > { ic_cdk::call(self.0, "get_node_provider_by_caller", (arg0,)).await }
  pub async fn get_pending_proposals(&self) -> CallResult<
    (Vec<ProposalInfo>,)
  > { ic_cdk::call(self.0, "get_pending_proposals", ()).await }
  pub async fn get_proposal_info(&self, arg0: u64) -> CallResult<
    (Option<ProposalInfo>,)
  > { ic_cdk::call(self.0, "get_proposal_info", (arg0,)).await }
  pub async fn get_restore_aging_summary(&self) -> CallResult<
    (RestoreAgingSummary,)
  > { ic_cdk::call(self.0, "get_restore_aging_summary", ()).await }
  pub async fn list_known_neurons(&self) -> CallResult<
    (ListKnownNeuronsResponse,)
  > { ic_cdk::call(self.0, "list_known_neurons", ()).await }
  pub async fn list_neurons(&self, arg0: ListNeurons) -> CallResult<
    (ListNeuronsResponse,)
  > { ic_cdk::call(self.0, "list_neurons", (arg0,)).await }
  pub async fn list_node_provider_rewards(
    &self,
    arg0: ListNodeProviderRewardsRequest,
  ) -> CallResult<(ListNodeProviderRewardsResponse,)> {
    ic_cdk::call(self.0, "list_node_provider_rewards", (arg0,)).await
  }
  pub async fn list_node_providers(&self) -> CallResult<
    (ListNodeProvidersResponse,)
  > { ic_cdk::call(self.0, "list_node_providers", ()).await }
  pub async fn list_proposals(&self, arg0: ListProposalInfo) -> CallResult<
    (ListProposalInfoResponse,)
  > { ic_cdk::call(self.0, "list_proposals", (arg0,)).await }
  pub async fn manage_neuron(&self, arg0: ManageNeuronRequest) -> CallResult<
    (ManageNeuronResponse,)
  > { ic_cdk::call(self.0, "manage_neuron", (arg0,)).await }
  pub async fn settle_community_fund_participation(
    &self,
    arg0: SettleCommunityFundParticipation,
  ) -> CallResult<(Result,)> {
    ic_cdk::call(self.0, "settle_community_fund_participation", (arg0,)).await
  }
  pub async fn settle_neurons_fund_participation(
    &self,
    arg0: SettleNeuronsFundParticipationRequest,
  ) -> CallResult<(SettleNeuronsFundParticipationResponse,)> {
    ic_cdk::call(self.0, "settle_neurons_fund_participation", (arg0,)).await
  }
  pub async fn simulate_manage_neuron(
    &self,
    arg0: ManageNeuronRequest,
  ) -> CallResult<(ManageNeuronResponse,)> {
    ic_cdk::call(self.0, "simulate_manage_neuron", (arg0,)).await
  }
  pub async fn transfer_gtc_neuron(
    &self,
    arg0: NeuronId,
    arg1: NeuronId,
  ) -> CallResult<(Result,)> {
    ic_cdk::call(self.0, "transfer_gtc_neuron", (arg0,arg1,)).await
  }
  pub async fn update_node_provider(
    &self,
    arg0: UpdateNodeProvider,
  ) -> CallResult<(Result,)> {
    ic_cdk::call(self.0, "update_node_provider", (arg0,)).await
  }
}
