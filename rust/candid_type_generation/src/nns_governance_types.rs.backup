// This is an experimental feature to generate Rust binding from Candid.
// You may want to manually adjust some of the types.
#![allow(dead_code, unused_imports)]
use candid::{self, CandidType, Deserialize, Principal};
use ic_cdk::api::call::CallResult as Result;

#[derive(CandidType, Deserialize)]
pub struct NeuronId { pub id: u64 }
#[derive(CandidType, Deserialize)]
pub struct Followees { pub followees: Vec<NeuronId> }
#[derive(CandidType, Deserialize)]
pub struct KnownNeuronData { pub name: String, pub description: Option<String> }
#[derive(CandidType, Deserialize)]
pub struct KnownNeuron {
  pub id: Option<NeuronId>,
  pub known_neuron_data: Option<KnownNeuronData>,
}
/// Creates a rented subnet from a rental request (in the Subnet Rental
/// canister).
#[derive(CandidType, Deserialize)]
pub struct FulfillSubnetRentalRequest {
  /// Identifies which rental request to fulfill.
  /// 
  /// (Identifying the rental request by user works, because a user can have at
  /// most one rental request in the Subnet Rental canister).
  pub user: Option<Principal>,
  /// What software the nodes will run.
  /// 
  /// This must be approved by a prior proposal to bless an IC OS version.
  /// 
  /// This is a full git commit ID in the ic repo. (Therefore, it must be a 40
  /// character hexidecimal string.)
  pub replica_version_id: Option<String>,
  /// Which nodes will be members of the subnet.
  pub node_ids: Option<Vec<Principal>>,
}
#[derive(CandidType, Deserialize)]
pub struct Spawn {
  pub percentage_to_spawn: Option<u32>,
  pub new_controller: Option<Principal>,
  pub nonce: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct Split {
  pub memo: Option<u64>,
  #[serde(rename="amount_e8s")]
  pub amount_e_8_s: u64,
}
#[derive(CandidType, Deserialize)]
pub struct Follow { pub topic: i32, pub followees: Vec<NeuronId> }
#[derive(CandidType, Deserialize)]
pub struct AccountIdentifier { pub hash: serde_bytes::ByteBuf }
#[derive(CandidType, Deserialize)]
pub struct Account {
  pub owner: Option<Principal>,
  pub subaccount: Option<serde_bytes::ByteBuf>,
}
#[derive(CandidType, Deserialize)]
pub struct DisburseMaturity {
  pub to_account_identifier: Option<AccountIdentifier>,
  pub to_account: Option<Account>,
  pub percentage_to_disburse: u32,
}
/// This is one way for a neuron to make sure that its deciding_voting_power is
/// not less than its potential_voting_power. See the description of those fields
/// in Neuron.
#[derive(CandidType, Deserialize)]
pub struct RefreshVotingPower {}
#[derive(CandidType, Deserialize)]
pub struct ClaimOrRefreshNeuronFromAccount {
  pub controller: Option<Principal>,
  pub memo: u64,
}
#[derive(CandidType, Deserialize)]
pub enum By {
  NeuronIdOrSubaccount{},
  MemoAndController(ClaimOrRefreshNeuronFromAccount),
  Memo(u64),
}
#[derive(CandidType, Deserialize)]
pub struct ClaimOrRefresh { pub by: Option<By> }
#[derive(CandidType, Deserialize)]
pub struct RemoveHotKey { pub hot_key_to_remove: Option<Principal> }
#[derive(CandidType, Deserialize)]
pub struct AddHotKey { pub new_hot_key: Option<Principal> }
#[derive(CandidType, Deserialize)]
pub struct ChangeAutoStakeMaturity {
  pub requested_setting_for_auto_stake_maturity: bool,
}
#[derive(CandidType, Deserialize)]
pub struct IncreaseDissolveDelay { pub additional_dissolve_delay_seconds: u32 }
#[derive(CandidType, Deserialize)]
pub struct SetVisibility { pub visibility: Option<i32> }
#[derive(CandidType, Deserialize)]
pub struct SetDissolveTimestamp { pub dissolve_timestamp_seconds: u64 }
#[derive(CandidType, Deserialize)]
pub enum Operation {
  RemoveHotKey(RemoveHotKey),
  AddHotKey(AddHotKey),
  ChangeAutoStakeMaturity(ChangeAutoStakeMaturity),
  StopDissolving{},
  StartDissolving{},
  IncreaseDissolveDelay(IncreaseDissolveDelay),
  SetVisibility(SetVisibility),
  JoinCommunityFund{},
  LeaveCommunityFund{},
  SetDissolveTimestamp(SetDissolveTimestamp),
}
#[derive(CandidType, Deserialize)]
pub struct Configure { pub operation: Option<Operation> }
#[derive(CandidType, Deserialize)]
pub struct ProposalId { pub id: u64 }
#[derive(CandidType, Deserialize)]
pub struct RegisterVote { pub vote: i32, pub proposal: Option<ProposalId> }
#[derive(CandidType, Deserialize)]
pub struct Merge { pub source_neuron_id: Option<NeuronId> }
#[derive(CandidType, Deserialize)]
pub struct DisburseToNeuron {
  pub dissolve_delay_seconds: u64,
  pub kyc_verified: bool,
  #[serde(rename="amount_e8s")]
  pub amount_e_8_s: u64,
  pub new_controller: Option<Principal>,
  pub nonce: u64,
}
#[derive(CandidType, Deserialize)]
pub struct FolloweesForTopic {
  pub topic: Option<i32>,
  pub followees: Option<Vec<NeuronId>>,
}
#[derive(CandidType, Deserialize)]
pub struct SetFollowing { pub topic_following: Option<Vec<FolloweesForTopic>> }
#[derive(CandidType, Deserialize)]
pub struct StakeMaturity { pub percentage_to_stake: Option<u32> }
#[derive(CandidType, Deserialize)]
pub struct MergeMaturity { pub percentage_to_merge: u32 }
#[derive(CandidType, Deserialize)]
pub struct Amount { #[serde(rename="e8s")] pub e_8_s: u64 }
#[derive(CandidType, Deserialize)]
pub struct Disburse {
  pub to_account: Option<AccountIdentifier>,
  pub amount: Option<Amount>,
}
/// KEEP THIS IN SYNC WITH ManageNeuronCommandRequest!
#[derive(CandidType, Deserialize)]
pub enum Command {
  Spawn(Spawn),
  Split(Split),
  Follow(Follow),
  DisburseMaturity(DisburseMaturity),
  RefreshVotingPower(RefreshVotingPower),
  ClaimOrRefresh(ClaimOrRefresh),
  Configure(Configure),
  RegisterVote(RegisterVote),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SetFollowing(SetFollowing),
  MakeProposal(Box<Proposal>),
  StakeMaturity(StakeMaturity),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}
#[derive(CandidType, Deserialize)]
pub enum NeuronIdOrSubaccount {
  Subaccount(serde_bytes::ByteBuf),
  NeuronId(NeuronId),
}
/// Not to be confused with ManageNeuronRequest. (Yes, this is very structurally
/// similar to that, but not actually exactly equivalent.)
#[derive(CandidType, Deserialize)]
pub struct ManageNeuron {
  pub id: Option<NeuronId>,
  pub command: Option<Command>,
  pub neuron_id_or_subaccount: Option<NeuronIdOrSubaccount>,
}
#[derive(CandidType, Deserialize)]
pub struct Controllers { pub controllers: Vec<Principal> }
#[derive(CandidType, Deserialize)]
pub struct CanisterSettings {
  pub freezing_threshold: Option<u64>,
  pub wasm_memory_threshold: Option<u64>,
  pub controllers: Option<Controllers>,
  pub log_visibility: Option<i32>,
  pub wasm_memory_limit: Option<u64>,
  pub memory_allocation: Option<u64>,
  pub compute_allocation: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct UpdateCanisterSettings {
  pub canister_id: Option<Principal>,
  pub settings: Option<CanisterSettings>,
}
#[derive(CandidType, Deserialize)]
pub struct InstallCode {
  pub skip_stopping_before_installing: Option<bool>,
  pub wasm_module_hash: Option<serde_bytes::ByteBuf>,
  pub canister_id: Option<Principal>,
  pub arg_hash: Option<serde_bytes::ByteBuf>,
  pub install_mode: Option<i32>,
}
#[derive(CandidType, Deserialize)]
pub struct StopOrStartCanister {
  pub action: Option<i32>,
  pub canister_id: Option<Principal>,
}
#[derive(CandidType, Deserialize)]
pub struct Percentage { pub basis_points: Option<u64> }
#[derive(CandidType, Deserialize)]
pub struct Duration { pub seconds: Option<u64> }
#[derive(CandidType, Deserialize)]
pub struct Tokens { #[serde(rename="e8s")] pub e_8_s: Option<u64> }
#[derive(CandidType, Deserialize)]
pub struct VotingRewardParameters {
  pub reward_rate_transition_duration: Option<Duration>,
  pub initial_reward_rate: Option<Percentage>,
  pub final_reward_rate: Option<Percentage>,
}
#[derive(CandidType, Deserialize)]
pub struct GovernanceParameters {
  pub neuron_maximum_dissolve_delay_bonus: Option<Percentage>,
  pub neuron_maximum_age_for_age_bonus: Option<Duration>,
  pub neuron_maximum_dissolve_delay: Option<Duration>,
  pub neuron_minimum_dissolve_delay_to_vote: Option<Duration>,
  pub neuron_maximum_age_bonus: Option<Percentage>,
  pub neuron_minimum_stake: Option<Tokens>,
  pub proposal_wait_for_quiet_deadline_increase: Option<Duration>,
  pub proposal_initial_voting_period: Option<Duration>,
  pub proposal_rejection_fee: Option<Tokens>,
  pub voting_reward_parameters: Option<VotingRewardParameters>,
}
#[derive(CandidType, Deserialize)]
pub struct Image {
  #[serde(rename="base64_encoding")]
  pub base_64_encoding: Option<String>,
}
#[derive(CandidType, Deserialize)]
pub struct LedgerParameters {
  pub transaction_fee: Option<Tokens>,
  pub token_symbol: Option<String>,
  pub token_logo: Option<Image>,
  pub token_name: Option<String>,
}
#[derive(CandidType, Deserialize)]
pub struct Canister { pub id: Option<Principal> }
#[derive(CandidType, Deserialize)]
pub struct NeuronBasketConstructionParameters {
  pub dissolve_delay_interval: Option<Duration>,
  pub count: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct GlobalTimeOfDay { pub seconds_after_utc_midnight: Option<u64> }
#[derive(CandidType, Deserialize)]
pub struct Countries { pub iso_codes: Vec<String> }
#[derive(CandidType, Deserialize)]
pub struct SwapParameters {
  pub minimum_participants: Option<u64>,
  pub neurons_fund_participation: Option<bool>,
  pub duration: Option<Duration>,
  pub neuron_basket_construction_parameters: Option<
    NeuronBasketConstructionParameters
  >,
  pub confirmation_text: Option<String>,
  pub maximum_participant_icp: Option<Tokens>,
  pub minimum_icp: Option<Tokens>,
  pub minimum_direct_participation_icp: Option<Tokens>,
  pub minimum_participant_icp: Option<Tokens>,
  pub start_time: Option<GlobalTimeOfDay>,
  pub maximum_direct_participation_icp: Option<Tokens>,
  pub maximum_icp: Option<Tokens>,
  pub neurons_fund_investment_icp: Option<Tokens>,
  pub restricted_countries: Option<Countries>,
}
#[derive(CandidType, Deserialize)]
pub struct SwapDistribution { pub total: Option<Tokens> }
#[derive(CandidType, Deserialize)]
pub struct NeuronDistribution {
  pub controller: Option<Principal>,
  pub dissolve_delay: Option<Duration>,
  pub memo: Option<u64>,
  pub vesting_period: Option<Duration>,
  pub stake: Option<Tokens>,
}
#[derive(CandidType, Deserialize)]
pub struct DeveloperDistribution {
  pub developer_neurons: Vec<NeuronDistribution>,
}
#[derive(CandidType, Deserialize)]
pub struct InitialTokenDistribution {
  pub treasury_distribution: Option<SwapDistribution>,
  pub developer_distribution: Option<DeveloperDistribution>,
  pub swap_distribution: Option<SwapDistribution>,
}
#[derive(CandidType, Deserialize)]
pub struct CreateServiceNervousSystem {
  pub url: Option<String>,
  pub governance_parameters: Option<GovernanceParameters>,
  pub fallback_controller_principal_ids: Vec<Principal>,
  pub logo: Option<Image>,
  pub name: Option<String>,
  pub ledger_parameters: Option<LedgerParameters>,
  pub description: Option<String>,
  pub dapp_canisters: Vec<Canister>,
  pub swap_parameters: Option<SwapParameters>,
  pub initial_token_distribution: Option<InitialTokenDistribution>,
}
#[derive(CandidType, Deserialize)]
pub struct ExecuteNnsFunction {
  pub nns_function: i32,
  pub payload: serde_bytes::ByteBuf,
}
#[derive(CandidType, Deserialize)]
pub struct NodeProvider {
  pub id: Option<Principal>,
  pub reward_account: Option<AccountIdentifier>,
}
#[derive(CandidType, Deserialize)]
pub struct RewardToNeuron { pub dissolve_delay_seconds: u64 }
#[derive(CandidType, Deserialize)]
pub struct RewardToAccount { pub to_account: Option<AccountIdentifier> }
#[derive(CandidType, Deserialize)]
pub enum RewardMode {
  RewardToNeuron(RewardToNeuron),
  RewardToAccount(RewardToAccount),
}
#[derive(CandidType, Deserialize)]
pub struct RewardNodeProvider {
  pub node_provider: Option<NodeProvider>,
  pub reward_mode: Option<RewardMode>,
  #[serde(rename="amount_e8s")]
  pub amount_e_8_s: u64,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronBasketConstructionParameters1 {
  pub dissolve_delay_interval_seconds: u64,
  pub count: u64,
}
#[derive(CandidType, Deserialize)]
pub struct Params {
  #[serde(rename="min_participant_icp_e8s")]
  pub min_participant_icp_e_8_s: u64,
  pub neuron_basket_construction_parameters: Option<
    NeuronBasketConstructionParameters1
  >,
  #[serde(rename="max_icp_e8s")]
  pub max_icp_e_8_s: u64,
  pub swap_due_timestamp_seconds: u64,
  pub min_participants: u32,
  #[serde(rename="sns_token_e8s")]
  pub sns_token_e_8_s: u64,
  pub sale_delay_seconds: Option<u64>,
  #[serde(rename="max_participant_icp_e8s")]
  pub max_participant_icp_e_8_s: u64,
  #[serde(rename="min_direct_participation_icp_e8s")]
  pub min_direct_participation_icp_e_8_s: Option<u64>,
  #[serde(rename="min_icp_e8s")]
  pub min_icp_e_8_s: u64,
  #[serde(rename="max_direct_participation_icp_e8s")]
  pub max_direct_participation_icp_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct OpenSnsTokenSwap {
  #[serde(rename="community_fund_investment_e8s")]
  pub community_fund_investment_e_8_s: Option<u64>,
  pub target_swap_canister_id: Option<Principal>,
  pub params: Option<Params>,
}
#[derive(CandidType, Deserialize)]
pub struct TimeWindow {
  pub start_timestamp_seconds: u64,
  pub end_timestamp_seconds: u64,
}
#[derive(CandidType, Deserialize)]
pub struct SetOpenTimeWindowRequest { pub open_time_window: Option<TimeWindow> }
#[derive(CandidType, Deserialize)]
pub struct SetSnsTokenSwapOpenTimeWindow {
  pub request: Option<SetOpenTimeWindowRequest>,
  pub swap_canister_id: Option<Principal>,
}
#[derive(CandidType, Deserialize)]
pub struct SetDefaultFollowees { pub default_followees: Vec<(i32,Followees,)> }
#[derive(CandidType, Deserialize)]
pub struct RewardNodeProviders {
  pub use_registry_derived_rewards: Option<bool>,
  pub rewards: Vec<RewardNodeProvider>,
}
/// Parameters that affect the voting power of neurons.
#[derive(CandidType, Deserialize)]
pub struct VotingPowerEconomics {
  /// If a neuron has not "refreshed" its voting power after this amount of time,
  /// its deciding voting power starts decreasing linearly. See also
  /// clear_following_after_seconds.
  /// 
  /// For explanation of what "refresh" means in this context, see
  /// https://dashboard.internetcomputer.org/proposal/132411
  /// 
  /// Initially, set to 0.5 years. (The nominal length of a year is 365.25 days).
  pub start_reducing_voting_power_after_seconds: Option<u64>,
  /// The minimum dissolve delay a neuron must have in order to be eligible to vote.
  /// 
  /// Neurons with a dissolve delay lower than this threshold will not have
  /// voting power, even if they are otherwise active.
  /// 
  /// This value is an essential part of the staking mechanism, promoting
  /// long-term alignment with the network's governance.
  pub neuron_minimum_dissolve_delay_to_vote_seconds: Option<u64>,
  /// After a neuron has experienced voting power reduction for this amount of
  /// time, a couple of things happen:
  /// 
  /// 1. Deciding voting power reaches 0.
  /// 
  /// 2. Its following on topics other than NeuronManagement are cleared.
  /// 
  /// Initially, set to 1/12 years.
  pub clear_following_after_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct Decimal { pub human_readable: Option<String> }
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundMatchedFundingCurveCoefficients {
  pub contribution_threshold_xdr: Option<Decimal>,
  pub one_third_participation_milestone_xdr: Option<Decimal>,
  pub full_participation_milestone_xdr: Option<Decimal>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundEconomics {
  pub maximum_icp_xdr_rate: Option<Percentage>,
  pub neurons_fund_matched_funding_curve_coefficients: Option<
    NeuronsFundMatchedFundingCurveCoefficients
  >,
  pub max_theoretical_neurons_fund_participation_amount_xdr: Option<Decimal>,
  pub minimum_icp_xdr_rate: Option<Percentage>,
}
#[derive(CandidType, Deserialize)]
pub struct NetworkEconomics {
  #[serde(rename="neuron_minimum_stake_e8s")]
  pub neuron_minimum_stake_e_8_s: u64,
  /// Parameters that affect the voting power of neurons.
  pub voting_power_economics: Option<VotingPowerEconomics>,
  pub max_proposals_to_keep_per_topic: u32,
  #[serde(rename="neuron_management_fee_per_proposal_e8s")]
  pub neuron_management_fee_per_proposal_e_8_s: u64,
  #[serde(rename="reject_cost_e8s")]
  pub reject_cost_e_8_s: u64,
  #[serde(rename="transaction_fee_e8s")]
  pub transaction_fee_e_8_s: u64,
  pub neuron_spawn_dissolve_delay_seconds: u64,
  pub minimum_icp_xdr_rate: u64,
  #[serde(rename="maximum_node_provider_rewards_e8s")]
  pub maximum_node_provider_rewards_e_8_s: u64,
  pub neurons_fund_economics: Option<NeuronsFundEconomics>,
}
#[derive(CandidType, Deserialize)]
pub struct Principals { pub principals: Vec<Principal> }
#[derive(CandidType, Deserialize)]
pub enum Change { ToRemove(NodeProvider), ToAdd(NodeProvider) }
#[derive(CandidType, Deserialize)]
pub struct AddOrRemoveNodeProvider { pub change: Option<Change> }
#[derive(CandidType, Deserialize)]
pub struct Motion { pub motion_text: String }
#[derive(CandidType, Deserialize)]
pub enum Action {
  RegisterKnownNeuron(KnownNeuron),
  FulfillSubnetRentalRequest(FulfillSubnetRentalRequest),
  ManageNeuron(ManageNeuron),
  UpdateCanisterSettings(UpdateCanisterSettings),
  InstallCode(InstallCode),
  StopOrStartCanister(StopOrStartCanister),
  CreateServiceNervousSystem(CreateServiceNervousSystem),
  ExecuteNnsFunction(ExecuteNnsFunction),
  RewardNodeProvider(RewardNodeProvider),
  OpenSnsTokenSwap(OpenSnsTokenSwap),
  SetSnsTokenSwapOpenTimeWindow(SetSnsTokenSwapOpenTimeWindow),
  SetDefaultFollowees(SetDefaultFollowees),
  RewardNodeProviders(RewardNodeProviders),
  ManageNetworkEconomics(NetworkEconomics),
  ApproveGenesisKyc(Principals),
  AddOrRemoveNodeProvider(AddOrRemoveNodeProvider),
  Motion(Motion),
}
#[derive(CandidType, Deserialize)]
pub struct Proposal {
  pub url: String,
  pub title: Option<String>,
  pub action: Option<Action>,
  pub summary: String,
}
#[derive(CandidType, Deserialize)]
pub struct MakingSnsProposal {
  pub proposal: Option<Box<Proposal>>,
  pub caller: Option<Principal>,
  pub proposer_id: Option<NeuronId>,
}
#[derive(CandidType, Deserialize)]
pub struct XdrConversionRate {
  pub xdr_permyriad_per_icp: Option<u64>,
  pub timestamp_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct MonthlyNodeProviderRewards {
  pub minimum_xdr_permyriad_per_icp: Option<u64>,
  pub registry_version: Option<u64>,
  pub node_providers: Vec<NodeProvider>,
  pub timestamp: u64,
  pub rewards: Vec<RewardNodeProvider>,
  pub xdr_conversion_rate: Option<XdrConversionRate>,
  #[serde(rename="maximum_node_provider_rewards_e8s")]
  pub maximum_node_provider_rewards_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronSubsetMetrics {
  #[serde(rename="total_maturity_e8s_equivalent")]
  pub total_maturity_e_8_s_equivalent: Option<u64>,
  #[serde(rename="maturity_e8s_equivalent_buckets")]
  pub maturity_e_8_s_equivalent_buckets: Vec<(u64,u64,)>,
  pub voting_power_buckets: Vec<(u64,u64,)>,
  #[serde(rename="total_staked_e8s")]
  pub total_staked_e_8_s: Option<u64>,
  pub count: Option<u64>,
  pub deciding_voting_power_buckets: Vec<(u64,u64,)>,
  #[serde(rename="total_staked_maturity_e8s_equivalent")]
  pub total_staked_maturity_e_8_s_equivalent: Option<u64>,
  pub total_potential_voting_power: Option<u64>,
  pub total_deciding_voting_power: Option<u64>,
  #[serde(rename="staked_maturity_e8s_equivalent_buckets")]
  pub staked_maturity_e_8_s_equivalent_buckets: Vec<(u64,u64,)>,
  #[serde(rename="staked_e8s_buckets")]
  pub staked_e_8_s_buckets: Vec<(u64,u64,)>,
  pub total_voting_power: Option<u64>,
  pub potential_voting_power_buckets: Vec<(u64,u64,)>,
  pub count_buckets: Vec<(u64,u64,)>,
}
#[derive(CandidType, Deserialize)]
pub struct GovernanceCachedMetrics {
  #[serde(rename="total_maturity_e8s_equivalent")]
  pub total_maturity_e_8_s_equivalent: u64,
  #[serde(rename="not_dissolving_neurons_e8s_buckets")]
  pub not_dissolving_neurons_e_8_s_buckets: Vec<(u64,f64,)>,
  #[serde(rename="dissolving_neurons_staked_maturity_e8s_equivalent_sum")]
  pub dissolving_neurons_staked_maturity_e_8_s_equivalent_sum: u64,
  pub garbage_collectable_neurons_count: u64,
  #[serde(rename="dissolving_neurons_staked_maturity_e8s_equivalent_buckets")]
  pub dissolving_neurons_staked_maturity_e_8_s_equivalent_buckets: Vec<
    (u64,f64,)
  >,
  pub neurons_with_invalid_stake_count: u64,
  pub not_dissolving_neurons_count_buckets: Vec<(u64,u64,)>,
  pub ect_neuron_count: u64,
  pub total_supply_icp: u64,
  pub neurons_with_less_than_6_months_dissolve_delay_count: u64,
  pub dissolved_neurons_count: u64,
  #[serde(rename="community_fund_total_maturity_e8s_equivalent")]
  pub community_fund_total_maturity_e_8_s_equivalent: u64,
  #[serde(rename="total_staked_e8s_seed")]
  pub total_staked_e_8_s_seed: u64,
  #[serde(rename="total_staked_maturity_e8s_equivalent_ect")]
  pub total_staked_maturity_e_8_s_equivalent_ect: u64,
  #[serde(rename="total_staked_e8s")]
  pub total_staked_e_8_s: u64,
  pub fully_lost_voting_power_neuron_subset_metrics: Option<
    NeuronSubsetMetrics
  >,
  pub not_dissolving_neurons_count: u64,
  #[serde(rename="total_locked_e8s")]
  pub total_locked_e_8_s: u64,
  pub neurons_fund_total_active_neurons: u64,
  pub total_voting_power_non_self_authenticating_controller: Option<u64>,
  #[serde(rename="total_staked_maturity_e8s_equivalent")]
  pub total_staked_maturity_e_8_s_equivalent: u64,
  #[serde(rename="not_dissolving_neurons_e8s_buckets_ect")]
  pub not_dissolving_neurons_e_8_s_buckets_ect: Vec<(u64,f64,)>,
  pub spawning_neurons_count: u64,
  pub declining_voting_power_neuron_subset_metrics: Option<NeuronSubsetMetrics>,
  #[serde(rename="total_staked_e8s_ect")]
  pub total_staked_e_8_s_ect: u64,
  #[serde(rename="not_dissolving_neurons_staked_maturity_e8s_equivalent_sum")]
  pub not_dissolving_neurons_staked_maturity_e_8_s_equivalent_sum: u64,
  #[serde(rename="dissolved_neurons_e8s")]
  pub dissolved_neurons_e_8_s: u64,
  #[serde(rename="total_staked_e8s_non_self_authenticating_controller")]
  pub total_staked_e_8_s_non_self_authenticating_controller: Option<u64>,
  #[serde(rename="dissolving_neurons_e8s_buckets_seed")]
  pub dissolving_neurons_e_8_s_buckets_seed: Vec<(u64,f64,)>,
  #[serde(rename="neurons_with_less_than_6_months_dissolve_delay_e8s")]
  pub neurons_with_less_than_6_months_dissolve_delay_e_8_s: u64,
  #[serde(rename="not_dissolving_neurons_staked_maturity_e8s_equivalent_buckets")]
  pub not_dissolving_neurons_staked_maturity_e_8_s_equivalent_buckets: Vec<
    (u64,f64,)
  >,
  pub dissolving_neurons_count_buckets: Vec<(u64,u64,)>,
  #[serde(rename="dissolving_neurons_e8s_buckets_ect")]
  pub dissolving_neurons_e_8_s_buckets_ect: Vec<(u64,f64,)>,
  pub non_self_authenticating_controller_neuron_subset_metrics: Option<
    NeuronSubsetMetrics
  >,
  pub dissolving_neurons_count: u64,
  #[serde(rename="dissolving_neurons_e8s_buckets")]
  pub dissolving_neurons_e_8_s_buckets: Vec<(u64,f64,)>,
  #[serde(rename="total_staked_maturity_e8s_equivalent_seed")]
  pub total_staked_maturity_e_8_s_equivalent_seed: u64,
  #[serde(rename="community_fund_total_staked_e8s")]
  pub community_fund_total_staked_e_8_s: u64,
  #[serde(rename="not_dissolving_neurons_e8s_buckets_seed")]
  pub not_dissolving_neurons_e_8_s_buckets_seed: Vec<(u64,f64,)>,
  pub public_neuron_subset_metrics: Option<NeuronSubsetMetrics>,
  pub timestamp_seconds: u64,
  pub seed_neuron_count: u64,
}
#[derive(CandidType, Deserialize)]
pub struct RestoreAgingNeuronGroup {
  pub count: Option<u64>,
  #[serde(rename="previous_total_stake_e8s")]
  pub previous_total_stake_e_8_s: Option<u64>,
  #[serde(rename="current_total_stake_e8s")]
  pub current_total_stake_e_8_s: Option<u64>,
  pub group_type: i32,
}
#[derive(CandidType, Deserialize)]
pub struct RestoreAgingSummary {
  pub groups: Vec<RestoreAgingNeuronGroup>,
  pub timestamp_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct RewardEvent {
  pub rounds_since_last_distribution: Option<u64>,
  pub day_after_genesis: u64,
  pub actual_timestamp_seconds: u64,
  #[serde(rename="total_available_e8s_equivalent")]
  pub total_available_e_8_s_equivalent: u64,
  #[serde(rename="latest_round_available_e8s_equivalent")]
  pub latest_round_available_e_8_s_equivalent: Option<u64>,
  #[serde(rename="distributed_e8s_equivalent")]
  pub distributed_e_8_s_equivalent: u64,
  pub settled_proposals: Vec<ProposalId>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronStakeTransfer {
  pub to_subaccount: serde_bytes::ByteBuf,
  #[serde(rename="neuron_stake_e8s")]
  pub neuron_stake_e_8_s: u64,
  pub from: Option<Principal>,
  pub memo: u64,
  pub from_subaccount: serde_bytes::ByteBuf,
  pub transfer_timestamp: u64,
  pub block_height: u64,
}
#[derive(CandidType, Deserialize)]
pub struct GovernanceError { pub error_message: String, pub error_type: i32 }
#[derive(CandidType, Deserialize)]
pub struct Ballot { pub vote: i32, pub voting_power: u64 }
#[derive(CandidType, Deserialize)]
pub struct SwapParticipationLimits {
  #[serde(rename="min_participant_icp_e8s")]
  pub min_participant_icp_e_8_s: Option<u64>,
  #[serde(rename="max_participant_icp_e8s")]
  pub max_participant_icp_e_8_s: Option<u64>,
  #[serde(rename="min_direct_participation_icp_e8s")]
  pub min_direct_participation_icp_e_8_s: Option<u64>,
  #[serde(rename="max_direct_participation_icp_e8s")]
  pub max_direct_participation_icp_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundNeuronPortion {
  pub controller: Option<Principal>,
  pub hotkeys: Vec<Principal>,
  pub is_capped: Option<bool>,
  #[serde(rename="maturity_equivalent_icp_e8s")]
  pub maturity_equivalent_icp_e_8_s: Option<u64>,
  pub nns_neuron_id: Option<NeuronId>,
  #[serde(rename="amount_icp_e8s")]
  pub amount_icp_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundSnapshot {
  pub neurons_fund_neuron_portions: Vec<NeuronsFundNeuronPortion>,
}
#[derive(CandidType, Deserialize)]
pub struct IdealMatchedParticipationFunction {
  pub serialized_representation: Option<String>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundParticipation {
  #[serde(rename="total_maturity_equivalent_icp_e8s")]
  pub total_maturity_equivalent_icp_e_8_s: Option<u64>,
  #[serde(rename="intended_neurons_fund_participation_icp_e8s")]
  pub intended_neurons_fund_participation_icp_e_8_s: Option<u64>,
  #[serde(rename="direct_participation_icp_e8s")]
  pub direct_participation_icp_e_8_s: Option<u64>,
  pub swap_participation_limits: Option<SwapParticipationLimits>,
  #[serde(rename="max_neurons_fund_swap_participation_icp_e8s")]
  pub max_neurons_fund_swap_participation_icp_e_8_s: Option<u64>,
  pub neurons_fund_reserves: Option<NeuronsFundSnapshot>,
  pub ideal_matched_participation_function: Option<
    IdealMatchedParticipationFunction
  >,
  #[serde(rename="allocated_neurons_fund_participation_icp_e8s")]
  pub allocated_neurons_fund_participation_icp_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundData {
  pub final_neurons_fund_participation: Option<NeuronsFundParticipation>,
  pub initial_neurons_fund_participation: Option<NeuronsFundParticipation>,
  pub neurons_fund_refunds: Option<NeuronsFundSnapshot>,
}
#[derive(CandidType, Deserialize)]
pub struct CanisterStatusResultV2 {
  pub status: Option<i32>,
  pub freezing_threshold: Option<u64>,
  pub controllers: Vec<Principal>,
  pub memory_size: Option<u64>,
  pub cycles: Option<u64>,
  pub idle_cycles_burned_per_day: Option<u64>,
  pub module_hash: serde_bytes::ByteBuf,
}
#[derive(CandidType, Deserialize)]
pub struct CanisterSummary {
  pub status: Option<CanisterStatusResultV2>,
  pub canister_id: Option<Principal>,
}
#[derive(CandidType, Deserialize)]
pub struct SwapBackgroundInformation {
  pub ledger_index_canister_summary: Option<CanisterSummary>,
  pub fallback_controller_principal_ids: Vec<Principal>,
  pub ledger_archive_canister_summaries: Vec<CanisterSummary>,
  pub ledger_canister_summary: Option<CanisterSummary>,
  pub swap_canister_summary: Option<CanisterSummary>,
  pub governance_canister_summary: Option<CanisterSummary>,
  pub root_canister_summary: Option<CanisterSummary>,
  pub dapp_canister_summaries: Vec<CanisterSummary>,
}
#[derive(CandidType, Deserialize)]
pub struct DerivedProposalInformation {
  pub swap_background_information: Option<SwapBackgroundInformation>,
}
#[derive(CandidType, Deserialize)]
pub struct Tally {
  pub no: u64,
  pub yes: u64,
  pub total: u64,
  pub timestamp_seconds: u64,
}
#[derive(CandidType, Deserialize)]
pub struct WaitForQuietState { pub current_deadline_timestamp_seconds: u64 }
#[derive(CandidType, Deserialize)]
pub struct ProposalData {
  pub id: Option<ProposalId>,
  pub topic: Option<i32>,
  pub failure_reason: Option<GovernanceError>,
  pub ballots: Vec<(u64,Ballot,)>,
  pub proposal_timestamp_seconds: u64,
  pub reward_event_round: u64,
  pub failed_timestamp_seconds: u64,
  pub neurons_fund_data: Option<NeuronsFundData>,
  #[serde(rename="reject_cost_e8s")]
  pub reject_cost_e_8_s: u64,
  pub derived_proposal_information: Option<DerivedProposalInformation>,
  pub latest_tally: Option<Tally>,
  pub total_potential_voting_power: Option<u64>,
  pub sns_token_swap_lifecycle: Option<i32>,
  pub decided_timestamp_seconds: u64,
  pub proposal: Option<Box<Proposal>>,
  pub proposer: Option<NeuronId>,
  pub wait_for_quiet_state: Option<WaitForQuietState>,
  pub executed_timestamp_seconds: u64,
  #[serde(rename="original_total_community_fund_maturity_e8s_equivalent")]
  pub original_total_community_fund_maturity_e_8_s_equivalent: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub enum Command2 {
  Spawn(NeuronId),
  Split(Split),
  Configure(Configure),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SyncCommand{},
  ClaimOrRefreshNeuron(ClaimOrRefresh),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}
#[derive(CandidType, Deserialize)]
pub struct NeuronInFlightCommand {
  pub command: Option<Command2>,
  pub timestamp: u64,
}
#[derive(CandidType, Deserialize)]
pub struct BallotInfo { pub vote: i32, pub proposal_id: Option<ProposalId> }
#[derive(CandidType, Deserialize)]
pub struct MaturityDisbursement {
  pub account_identifier_to_disburse_to: Option<AccountIdentifier>,
  pub timestamp_of_disbursement_seconds: Option<u64>,
  #[serde(rename="amount_e8s")]
  pub amount_e_8_s: Option<u64>,
  pub account_to_disburse_to: Option<Account>,
  pub finalize_disbursement_timestamp_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub enum DissolveState {
  DissolveDelaySeconds(u64),
  WhenDissolvedTimestampSeconds(u64),
}
#[derive(CandidType, Deserialize)]
pub struct Neuron {
  pub id: Option<NeuronId>,
  #[serde(rename="staked_maturity_e8s_equivalent")]
  pub staked_maturity_e_8_s_equivalent: Option<u64>,
  pub controller: Option<Principal>,
  pub recent_ballots: Vec<BallotInfo>,
  pub voting_power_refreshed_timestamp_seconds: Option<u64>,
  pub kyc_verified: bool,
  /// The amount of "sway" this neuron can have if it refreshes its voting power
  /// frequently enough.
  /// 
  /// Unlike deciding_voting_power, this does NOT take refreshing into account.
  /// Rather, this only takes three factors into account:
  /// 
  /// 1. (Net) staked amount - This is the "base" of a neuron's voting power.
  /// This primarily consists of the neuron's ICP balance.
  /// 
  /// 2. Age - Neurons with more age have more voting power (all else being
  /// equal).
  /// 
  /// 3. Dissolve delay - Neurons with longer dissolve delay have more voting
  /// power (all else being equal). Neurons with a dissolve delay of less
  /// than six months are not eligible to vote. Therefore, such neurons
  /// are considered to have 0 voting power.
  /// 
  /// Per NNS policy, this is opt. Nevertheless, it will never be null.
  pub potential_voting_power: Option<u64>,
  pub neuron_type: Option<i32>,
  pub not_for_profit: bool,
  #[serde(rename="maturity_e8s_equivalent")]
  pub maturity_e_8_s_equivalent: u64,
  /// The amount of "sway" this neuron has when voting on proposals.
  /// 
  /// When a proposal is created, each eligible neuron gets a "blank" ballot. The
  /// amount of voting power in that ballot is set to the neuron's deciding
  /// voting power at the time of proposal creation. There are two ways that a
  /// proposal can become decided:
  /// 
  /// 1. Early: Either more than half of the total voting power in the ballots
  /// votes in favor (then the proposal is approved), or at least half of the
  /// votal voting power in the ballots votes against (then, the proposal is
  /// rejected).
  /// 
  /// 2. The proposal's voting deadline is reached. At that point, if there is
  /// more voting power in favor than against, and at least 3% of the total
  /// voting power voted in favor, then the proposal is approved. Otherwise, it
  /// is rejected.
  /// 
  /// If a neuron regularly refreshes its voting power, this has the same value
  /// as potential_voting_power. Actions that cause a refresh are as follows:
  /// 
  /// 1. voting directly (not via following)
  /// 2. set following
  /// 3. refresh voting power
  /// 
  /// (All of these actions are performed via the manage_neuron method.)
  /// 
  /// However, if a neuron has not refreshed in a "long" time, this will be less
  /// than potential voting power. See VotingPowerEconomics. As a further result
  /// of less deciding voting power, not only does it have less influence on the
  /// outcome of proposals, the neuron receives less voting rewards (when it
  /// votes indirectly via following).
  /// 
  /// For details, see https://dashboard.internetcomputer.org/proposal/132411.
  /// 
  /// Per NNS policy, this is opt. Nevertheless, it will never be null.
  pub deciding_voting_power: Option<u64>,
  #[serde(rename="cached_neuron_stake_e8s")]
  pub cached_neuron_stake_e_8_s: u64,
  pub created_timestamp_seconds: u64,
  pub auto_stake_maturity: Option<bool>,
  pub aging_since_timestamp_seconds: u64,
  pub hot_keys: Vec<Principal>,
  pub account: serde_bytes::ByteBuf,
  pub joined_community_fund_timestamp_seconds: Option<u64>,
  /// The maturity disbursements in progress, i.e. the disbursements that are initiated but not
  /// finalized. The finalization happens 7 days after the disbursement is initiated.
  pub maturity_disbursements_in_progress: Option<Vec<MaturityDisbursement>>,
  pub dissolve_state: Option<DissolveState>,
  pub followees: Vec<(i32,Followees,)>,
  #[serde(rename="neuron_fees_e8s")]
  pub neuron_fees_e_8_s: u64,
  pub visibility: Option<i32>,
  pub transfer: Option<NeuronStakeTransfer>,
  pub known_neuron_data: Option<KnownNeuronData>,
  pub spawn_at_timestamp_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct Governance {
  pub default_followees: Vec<(i32,Followees,)>,
  pub making_sns_proposal: Option<MakingSnsProposal>,
  pub most_recent_monthly_node_provider_rewards: Option<
    MonthlyNodeProviderRewards
  >,
  pub maturity_modulation_last_updated_at_timestamp_seconds: Option<u64>,
  pub wait_for_quiet_threshold_seconds: u64,
  pub metrics: Option<GovernanceCachedMetrics>,
  pub neuron_management_voting_period_seconds: Option<u64>,
  pub node_providers: Vec<NodeProvider>,
  pub cached_daily_maturity_modulation_basis_points: Option<i32>,
  pub economics: Option<NetworkEconomics>,
  pub restore_aging_summary: Option<RestoreAgingSummary>,
  pub spawning_neurons: Option<bool>,
  pub latest_reward_event: Option<RewardEvent>,
  pub to_claim_transfers: Vec<NeuronStakeTransfer>,
  pub short_voting_period_seconds: u64,
  pub proposals: Vec<(u64,ProposalData,)>,
  pub xdr_conversion_rate: Option<XdrConversionRate>,
  pub in_flight_commands: Vec<(u64,NeuronInFlightCommand,)>,
  pub neurons: Vec<(u64,Neuron,)>,
  pub genesis_timestamp_seconds: u64,
}
pub type Result_ = std::result::Result<(), GovernanceError>;
#[derive(CandidType, Deserialize)]
pub enum Result1 { Error(GovernanceError), NeuronId(NeuronId) }
#[derive(CandidType, Deserialize)]
pub struct ClaimOrRefreshNeuronFromAccountResponse {
  pub result: Option<Result1>,
}
pub type Result2 = std::result::Result<Neuron, GovernanceError>;
pub type Result3 = std::result::Result<
  GovernanceCachedMetrics, GovernanceError
>;
pub type Result4 = std::result::Result<
  MonthlyNodeProviderRewards, GovernanceError
>;
/// A limit view of Neuron that allows some aspects of all neurons to be read by
/// anyone (i.e. without having to be the neuron's controller nor one of its
/// hotkeys).
/// 
/// As such, the meaning of each field in this type is generally the same as the
/// one of the same (or at least similar) name in Neuron.
#[derive(CandidType, Deserialize)]
pub struct NeuronInfo {
  pub dissolve_delay_seconds: u64,
  pub recent_ballots: Vec<BallotInfo>,
  pub voting_power_refreshed_timestamp_seconds: Option<u64>,
  pub potential_voting_power: Option<u64>,
  pub neuron_type: Option<i32>,
  pub deciding_voting_power: Option<u64>,
  pub created_timestamp_seconds: u64,
  pub state: i32,
  /// The amount of ICP (and staked maturity) locked in this neuron.
  /// 
  /// This is the foundation of the neuron's voting power.
  /// 
  /// cached_neuron_stake_e8s - neuron_fees_e8s + staked_maturity_e8s_equivalent
  #[serde(rename="stake_e8s")]
  pub stake_e_8_s: u64,
  pub joined_community_fund_timestamp_seconds: Option<u64>,
  pub retrieved_at_timestamp_seconds: u64,
  pub visibility: Option<i32>,
  pub known_neuron_data: Option<KnownNeuronData>,
  /// Deprecated. Use either deciding_voting_power or potential_voting_power
  /// instead. Has the same value as deciding_voting_power.
  /// 
  /// Previously, if a neuron had < 6 months dissolve delay (making it ineligible
  /// to vote), this would not get set to 0 (zero). That was pretty confusing.
  /// Now that this is set to deciding_voting_power, this actually does get
  /// zeroed out.
  pub voting_power: u64,
  pub age_seconds: u64,
}
pub type Result5 = std::result::Result<NeuronInfo, GovernanceError>;
#[derive(CandidType, Deserialize)]
pub struct GetNeuronsFundAuditInfoRequest {
  pub nns_proposal_id: Option<ProposalId>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundAuditInfo {
  pub final_neurons_fund_participation: Option<NeuronsFundParticipation>,
  pub initial_neurons_fund_participation: Option<NeuronsFundParticipation>,
  pub neurons_fund_refunds: Option<NeuronsFundSnapshot>,
}
#[derive(CandidType, Deserialize)]
pub struct Ok { pub neurons_fund_audit_info: Option<NeuronsFundAuditInfo> }
pub type Result6 = std::result::Result<Ok, GovernanceError>;
#[derive(CandidType, Deserialize)]
pub struct GetNeuronsFundAuditInfoResponse { pub result: Option<Result6> }
pub type Result7 = std::result::Result<NodeProvider, GovernanceError>;
#[derive(CandidType, Deserialize)]
pub struct ProposalInfo {
  pub id: Option<ProposalId>,
  pub status: i32,
  pub topic: i32,
  pub failure_reason: Option<GovernanceError>,
  pub ballots: Vec<(u64,Ballot,)>,
  pub proposal_timestamp_seconds: u64,
  pub reward_event_round: u64,
  pub deadline_timestamp_seconds: Option<u64>,
  pub failed_timestamp_seconds: u64,
  #[serde(rename="reject_cost_e8s")]
  pub reject_cost_e_8_s: u64,
  pub derived_proposal_information: Option<DerivedProposalInformation>,
  pub latest_tally: Option<Tally>,
  pub total_potential_voting_power: Option<u64>,
  pub reward_status: i32,
  pub decided_timestamp_seconds: u64,
  pub proposal: Option<Box<Proposal>>,
  pub proposer: Option<NeuronId>,
  pub executed_timestamp_seconds: u64,
}
#[derive(CandidType, Deserialize)]
pub struct ListKnownNeuronsResponse { pub known_neurons: Vec<KnownNeuron> }
#[derive(CandidType, Deserialize)]
pub struct NeuronSubaccount { pub subaccount: serde_bytes::ByteBuf }
/// Parameters of the list_neurons method.
#[derive(CandidType, Deserialize)]
pub struct ListNeurons {
  pub page_size: Option<u64>,
  /// When a public neuron is a member of the result set, include it in the
  /// full_neurons field (of ListNeuronsResponse). This does not affect which
  /// neurons are part of the result set.
  pub include_public_neurons_in_full_neurons: Option<bool>,
  /// These fields select neurons to be in the result set.
  pub neuron_ids: Vec<u64>,
  pub page_number: Option<u64>,
  /// Only has an effect when include_neurons_readable_by_caller.
  pub include_empty_neurons_readable_by_caller: Option<bool>,
  pub neuron_subaccounts: Option<Vec<NeuronSubaccount>>,
  pub include_neurons_readable_by_caller: bool,
}
/// Output of the list_neurons method.
#[derive(CandidType, Deserialize)]
pub struct ListNeuronsResponse {
  /// Per the NeuronInfo type, this is a redacted view of the neurons in the
  /// result set consisting of information that require no special privileges to
  /// view.
  pub neuron_infos: Vec<(u64,NeuronInfo,)>,
  /// If the caller has the necessary special privileges (or the neuron is
  /// public, and the request sets include_public_neurons_in_full_neurons to
  /// true), then all the information about the neurons in the result set is made
  /// available here.
  pub full_neurons: Vec<Neuron>,
  pub total_pages_available: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct DateRangeFilter {
  pub start_timestamp_seconds: Option<u64>,
  pub end_timestamp_seconds: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct ListNodeProviderRewardsRequest {
  pub date_filter: Option<DateRangeFilter>,
}
#[derive(CandidType, Deserialize)]
pub struct ListNodeProviderRewardsResponse {
  pub rewards: Vec<MonthlyNodeProviderRewards>,
}
#[derive(CandidType, Deserialize)]
pub struct ListNodeProvidersResponse { pub node_providers: Vec<NodeProvider> }
#[derive(CandidType, Deserialize)]
pub struct ListProposalInfo {
  pub include_reward_status: Vec<i32>,
  pub omit_large_fields: Option<bool>,
  pub before_proposal: Option<ProposalId>,
  pub limit: u32,
  pub exclude_topic: Vec<i32>,
  pub include_all_manage_neuron_proposals: Option<bool>,
  pub include_status: Vec<i32>,
}
#[derive(CandidType, Deserialize)]
pub struct ListProposalInfoResponse { pub proposal_info: Vec<ProposalInfo> }
#[derive(CandidType, Deserialize)]
pub struct InstallCodeRequest {
  pub arg: Option<serde_bytes::ByteBuf>,
  pub wasm_module: Option<serde_bytes::ByteBuf>,
  pub skip_stopping_before_installing: Option<bool>,
  pub canister_id: Option<Principal>,
  pub install_mode: Option<i32>,
}
#[derive(CandidType, Deserialize)]
pub enum ProposalActionRequest {
  RegisterKnownNeuron(KnownNeuron),
  FulfillSubnetRentalRequest(FulfillSubnetRentalRequest),
  ManageNeuron(Box<ManageNeuronRequest>),
  UpdateCanisterSettings(UpdateCanisterSettings),
  InstallCode(InstallCodeRequest),
  StopOrStartCanister(StopOrStartCanister),
  CreateServiceNervousSystem(CreateServiceNervousSystem),
  ExecuteNnsFunction(ExecuteNnsFunction),
  RewardNodeProvider(RewardNodeProvider),
  RewardNodeProviders(RewardNodeProviders),
  ManageNetworkEconomics(NetworkEconomics),
  ApproveGenesisKyc(Principals),
  AddOrRemoveNodeProvider(AddOrRemoveNodeProvider),
  Motion(Motion),
}
#[derive(CandidType, Deserialize)]
pub struct MakeProposalRequest {
  pub url: String,
  pub title: Option<String>,
  pub action: Option<ProposalActionRequest>,
  pub summary: String,
}
/// KEEP THIS IN SYNC WITH COMMAND!
#[derive(CandidType, Deserialize)]
pub enum ManageNeuronCommandRequest {
  Spawn(Spawn),
  Split(Split),
  Follow(Follow),
  DisburseMaturity(DisburseMaturity),
  RefreshVotingPower(RefreshVotingPower),
  ClaimOrRefresh(ClaimOrRefresh),
  Configure(Configure),
  RegisterVote(RegisterVote),
  Merge(Merge),
  DisburseToNeuron(DisburseToNeuron),
  SetFollowing(SetFollowing),
  MakeProposal(MakeProposalRequest),
  StakeMaturity(StakeMaturity),
  MergeMaturity(MergeMaturity),
  Disburse(Disburse),
}
/// Parameters of the manage_neuron method.
#[derive(CandidType, Deserialize)]
pub struct ManageNeuronRequest {
  /// Deprecated. Use neuron_id_or_subaccount instead.
  pub id: Option<NeuronId>,
  /// What operation to perform on the neuron.
  pub command: Option<ManageNeuronCommandRequest>,
  /// Which neuron to operate on.
  pub neuron_id_or_subaccount: Option<NeuronIdOrSubaccount>,
}
#[derive(CandidType, Deserialize)]
pub struct SpawnResponse { pub created_neuron_id: Option<NeuronId> }
#[derive(CandidType, Deserialize)]
pub struct DisburseMaturityResponse {
  #[serde(rename="amount_disbursed_e8s")]
  pub amount_disbursed_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct RefreshVotingPowerResponse {}
#[derive(CandidType, Deserialize)]
pub struct ClaimOrRefreshResponse { pub refreshed_neuron_id: Option<NeuronId> }
#[derive(CandidType, Deserialize)]
pub struct MergeResponse {
  pub target_neuron: Option<Neuron>,
  pub source_neuron: Option<Neuron>,
  pub target_neuron_info: Option<NeuronInfo>,
  pub source_neuron_info: Option<NeuronInfo>,
}
#[derive(CandidType, Deserialize)]
pub struct SetFollowingResponse {}
#[derive(CandidType, Deserialize)]
pub struct MakeProposalResponse {
  pub message: Option<String>,
  pub proposal_id: Option<ProposalId>,
}
#[derive(CandidType, Deserialize)]
pub struct StakeMaturityResponse {
  #[serde(rename="maturity_e8s")]
  pub maturity_e_8_s: u64,
  #[serde(rename="staked_maturity_e8s")]
  pub staked_maturity_e_8_s: u64,
}
#[derive(CandidType, Deserialize)]
pub struct MergeMaturityResponse {
  #[serde(rename="merged_maturity_e8s")]
  pub merged_maturity_e_8_s: u64,
  #[serde(rename="new_stake_e8s")]
  pub new_stake_e_8_s: u64,
}
#[derive(CandidType, Deserialize)]
pub struct DisburseResponse { pub transfer_block_height: u64 }
#[derive(CandidType, Deserialize)]
pub enum Command1 {
  Error(GovernanceError),
  Spawn(SpawnResponse),
  Split(SpawnResponse),
  Follow{},
  DisburseMaturity(DisburseMaturityResponse),
  RefreshVotingPower(RefreshVotingPowerResponse),
  ClaimOrRefresh(ClaimOrRefreshResponse),
  Configure{},
  RegisterVote{},
  Merge(MergeResponse),
  DisburseToNeuron(SpawnResponse),
  SetFollowing(SetFollowingResponse),
  MakeProposal(MakeProposalResponse),
  StakeMaturity(StakeMaturityResponse),
  MergeMaturity(MergeMaturityResponse),
  Disburse(DisburseResponse),
}
/// Output of the manage_neuron method.
#[derive(CandidType, Deserialize)]
pub struct ManageNeuronResponse {
  /// Corresponds to the command field in ManageNeuronRequest, which determines
  /// what operation was performed.
  pub command: Option<Command1>,
}
#[derive(CandidType, Deserialize)]
pub struct Committed {
  #[serde(rename="total_direct_contribution_icp_e8s")]
  pub total_direct_contribution_icp_e_8_s: Option<u64>,
  #[serde(rename="total_neurons_fund_contribution_icp_e8s")]
  pub total_neurons_fund_contribution_icp_e_8_s: Option<u64>,
  pub sns_governance_canister_id: Option<Principal>,
}
#[derive(CandidType, Deserialize)]
pub enum Result8 { Committed(Committed), Aborted{} }
#[derive(CandidType, Deserialize)]
pub struct SettleCommunityFundParticipation {
  pub result: Option<Result8>,
  pub open_sns_token_swap_proposal_id: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct Committed1 {
  #[serde(rename="total_direct_participation_icp_e8s")]
  pub total_direct_participation_icp_e_8_s: Option<u64>,
  #[serde(rename="total_neurons_fund_participation_icp_e8s")]
  pub total_neurons_fund_participation_icp_e_8_s: Option<u64>,
  pub sns_governance_canister_id: Option<Principal>,
}
#[derive(CandidType, Deserialize)]
pub enum Result9 { Committed(Committed1), Aborted{} }
#[derive(CandidType, Deserialize)]
pub struct SettleNeuronsFundParticipationRequest {
  pub result: Option<Result9>,
  pub nns_proposal_id: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct NeuronsFundNeuron {
  pub controller: Option<Principal>,
  pub hotkeys: Option<Principals>,
  pub is_capped: Option<bool>,
  pub nns_neuron_id: Option<u64>,
  #[serde(rename="amount_icp_e8s")]
  pub amount_icp_e_8_s: Option<u64>,
}
#[derive(CandidType, Deserialize)]
pub struct Ok1 { pub neurons_fund_neuron_portions: Vec<NeuronsFundNeuron> }
pub type Result10 = std::result::Result<Ok1, GovernanceError>;
#[derive(CandidType, Deserialize)]
pub struct SettleNeuronsFundParticipationResponse {
  pub result: Option<Result10>,
}
#[derive(CandidType, Deserialize)]
pub struct UpdateNodeProvider { pub reward_account: Option<AccountIdentifier> }

pub struct Service(pub Principal);
impl Service {
  pub async fn claim_gtc_neurons(&self, arg0: &Principal, arg1: &Vec<NeuronId>) -> Result<(Result_,)> {
    ic_cdk::call(self.0, "claim_gtc_neurons", (arg0,arg1,)).await
  }
  pub async fn claim_or_refresh_neuron_from_account(&self, arg0: &ClaimOrRefreshNeuronFromAccount) -> Result<(ClaimOrRefreshNeuronFromAccountResponse,)> {
    ic_cdk::call(self.0, "claim_or_refresh_neuron_from_account", (arg0,)).await
  }
  pub async fn get_build_metadata(&self) -> Result<(String,)> {
    ic_cdk::call(self.0, "get_build_metadata", ()).await
  }
  pub async fn get_full_neuron(&self, arg0: &u64) -> Result<(Result2,)> {
    ic_cdk::call(self.0, "get_full_neuron", (arg0,)).await
  }
  pub async fn get_full_neuron_by_id_or_subaccount(&self, arg0: &NeuronIdOrSubaccount) -> Result<(Result2,)> {
    ic_cdk::call(self.0, "get_full_neuron_by_id_or_subaccount", (arg0,)).await
  }
  pub async fn get_latest_reward_event(&self) -> Result<(RewardEvent,)> {
    ic_cdk::call(self.0, "get_latest_reward_event", ()).await
  }
  pub async fn get_metrics(&self) -> Result<(Result3,)> {
    ic_cdk::call(self.0, "get_metrics", ()).await
  }
  pub async fn get_monthly_node_provider_rewards(&self) -> Result<(Result4,)> {
    ic_cdk::call(self.0, "get_monthly_node_provider_rewards", ()).await
  }
  pub async fn get_most_recent_monthly_node_provider_rewards(&self) -> Result<(Option<MonthlyNodeProviderRewards>,)> {
    ic_cdk::call(self.0, "get_most_recent_monthly_node_provider_rewards", ()).await
  }
  pub async fn get_network_economics_parameters(&self) -> Result<(NetworkEconomics,)> {
    ic_cdk::call(self.0, "get_network_economics_parameters", ()).await
  }
  pub async fn get_neuron_ids(&self) -> Result<(Vec<u64>,)> {
    ic_cdk::call(self.0, "get_neuron_ids", ()).await
  }
  pub async fn get_neuron_info(&self, arg0: &u64) -> Result<(Result5,)> {
    ic_cdk::call(self.0, "get_neuron_info", (arg0,)).await
  }
  pub async fn get_neuron_info_by_id_or_subaccount(&self, arg0: &NeuronIdOrSubaccount) -> Result<(Result5,)> {
    ic_cdk::call(self.0, "get_neuron_info_by_id_or_subaccount", (arg0,)).await
  }
  pub async fn get_neurons_fund_audit_info(&self, arg0: &GetNeuronsFundAuditInfoRequest) -> Result<(GetNeuronsFundAuditInfoResponse,)> {
    ic_cdk::call(self.0, "get_neurons_fund_audit_info", (arg0,)).await
  }
  pub async fn get_node_provider_by_caller(&self, arg0: &()) -> Result<(Result7,)> {
    ic_cdk::call(self.0, "get_node_provider_by_caller", (arg0,)).await
  }
  pub async fn get_pending_proposals(&self) -> Result<(Vec<ProposalInfo>,)> {
    ic_cdk::call(self.0, "get_pending_proposals", ()).await
  }
  pub async fn get_proposal_info(&self, arg0: &u64) -> Result<(Option<ProposalInfo>,)> {
    ic_cdk::call(self.0, "get_proposal_info", (arg0,)).await
  }
  pub async fn get_restore_aging_summary(&self) -> Result<(RestoreAgingSummary,)> {
    ic_cdk::call(self.0, "get_restore_aging_summary", ()).await
  }
  pub async fn list_known_neurons(&self) -> Result<(ListKnownNeuronsResponse,)> {
    ic_cdk::call(self.0, "list_known_neurons", ()).await
  }
  pub async fn list_neurons(&self, arg0: &ListNeurons) -> Result<(ListNeuronsResponse,)> {
    ic_cdk::call(self.0, "list_neurons", (arg0,)).await
  }
  pub async fn list_node_provider_rewards(&self, arg0: &ListNodeProviderRewardsRequest) -> Result<(ListNodeProviderRewardsResponse,)> {
    ic_cdk::call(self.0, "list_node_provider_rewards", (arg0,)).await
  }
  pub async fn list_node_providers(&self) -> Result<(ListNodeProvidersResponse,)> {
    ic_cdk::call(self.0, "list_node_providers", ()).await
  }
  pub async fn list_proposals(&self, arg0: &ListProposalInfo) -> Result<(ListProposalInfoResponse,)> {
    ic_cdk::call(self.0, "list_proposals", (arg0,)).await
  }
  pub async fn manage_neuron(&self, arg0: &ManageNeuronRequest) -> Result<(ManageNeuronResponse,)> {
    ic_cdk::call(self.0, "manage_neuron", (arg0,)).await
  }
  pub async fn settle_community_fund_participation(&self, arg0: &SettleCommunityFundParticipation) -> Result<(Result_,)> {
    ic_cdk::call(self.0, "settle_community_fund_participation", (arg0,)).await
  }
  pub async fn settle_neurons_fund_participation(&self, arg0: &SettleNeuronsFundParticipationRequest) -> Result<(SettleNeuronsFundParticipationResponse,)> {
    ic_cdk::call(self.0, "settle_neurons_fund_participation", (arg0,)).await
  }
  pub async fn simulate_manage_neuron(&self, arg0: &ManageNeuronRequest) -> Result<(ManageNeuronResponse,)> {
    ic_cdk::call(self.0, "simulate_manage_neuron", (arg0,)).await
  }
  pub async fn transfer_gtc_neuron(&self, arg0: &NeuronId, arg1: &NeuronId) -> Result<(Result_,)> {
    ic_cdk::call(self.0, "transfer_gtc_neuron", (arg0,arg1,)).await
  }
  pub async fn update_node_provider(&self, arg0: &UpdateNodeProvider) -> Result<(Result_,)> {
    ic_cdk::call(self.0, "update_node_provider", (arg0,)).await
  }
}

