<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../../invoice/Invoice.html">invoice/Invoice</a></li></li><li><li><a href="../../invoice/modules/Migration.html">invoice/modules/Migration</a></li></li><li><li><a href="../../invoice/modules/SupportedToken.html">invoice/modules/SupportedToken</a></li></li><li><li><a href="../../invoice/modules/Types.html">invoice/modules/Types</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Supertype_ICP_Actor">Supertype_ICP_Actor</a></li></li><li><li><a href="#type.Supertype_ICRC1_Actor">Supertype_ICRC1_Actor</a></li></li><li><li><a href="#type.SupportedToken">SupportedToken</a></li></li><li><li><a href="#type.UnitType">UnitType</a></li></li><li><li><a href="#type.Amount">Amount</a></li></li><li><li><a href="#type.Address">Address</a></li></li><li><li><a href="#type.TransferArgs">TransferArgs</a></li></li><li><li><a href="#type.TransferResult">TransferResult</a></li></li><li><li><a href="#type.TransferSuccess">TransferSuccess</a></li></li><li><li><a href="#type.TransferErr">TransferErr</a></li></li><li><li><a href="#type.RecipientAddress">RecipientAddress</a></li></li><li><li><a href="#type.TokenVerbose">TokenVerbose</a></li></li><li><li><a href="#getTokenVerbose">getTokenVerbose</a></li></li><li><li><a href="#getTransactionFee">getTransactionFee</a></li></li><li><li><a href="#unwrapTokenAmount">unwrapTokenAmount</a></li></li><li><li><a href="#wrapAsTokenAmount">wrapAsTokenAmount</a></li></li><li><li><a href="#encodeAddress">encodeAddress</a></li></li><li><li><a href="#encodeAddressOrUnitErr">encodeAddressOrUnitErr</a></li></li><li><li><a href="#getAddressOrUnitErr">getAddressOrUnitErr</a></li></li><li><li><a href="#getInvoiceSubaccountAddress">getInvoiceSubaccountAddress</a></li></li><li><li><a href="#getEncodedInvoiceSubaccountAddress">getEncodedInvoiceSubaccountAddress</a></li></li><li><li><a href="#getCreatorSubaccountAddress">getCreatorSubaccountAddress</a></li></li><li><li><a href="#getTransferArgsFromInvoiceSubaccount">getTransferArgsFromInvoiceSubaccount</a></li></li><li><li><a href="#getTransferArgsFromCreatorSubaccount">getTransferArgsFromCreatorSubaccount</a></li></li><li><li><a href="#rewrapTransferResults">rewrapTransferResults</a></li></li><li><li><a href="#getDefaultSubaccountAddress">getDefaultSubaccountAddress</a></li></li></ul></nav><div class="documentation"><h1>invoice/modules/SupportedToken</h1><p>If adding more ICRC1 token-ledger canisters, the <strong>only</strong> edits necessary in this file are the methods 
 declared after the <code>SupportedToken&lt;T1, T2&gt;</code> variant (ie in the <code>SupportedToken</code> module's outermost 
 scope). Add a new tag in this variant for each additional ICRC1 token-ledger canister to support, and 
 then update the corresponding switches in the methods that follow until all the cases are covered. The 
 only other changes necessary are the corresponding switch cases to be added in <code>Invoice.mo</code>. 
 Note that once the variant tag is added to <code>SupportedToken&lt;T1, T2&gt;</code> , this will cause the Motoko 
 VScode extension to indicate where all switches need to be updated to include the required cases 
 for supporting that token.<br/> Also note the <code>Supertype_ICRC1_Actor</code> type declaration can be reused in <code>Invoice.mo</code> as different
 instances to perform the corresponding intercanister calls to the token-ledger canisters of
 the additional ICRC1 tokens to support.</p>
<div class="declaration"><h4 class="type-declaration" id="type.Supertype_ICP_Actor"><span class="keyword">type </span><span class="type">Supertype_ICP_Actor</span> = <span class="type">TokenSpecific.ICP.Supertype.Actor</span></h4><p><p><strong>Externally accessible ICP ledger canister supertype actor included for consistency.</strong></p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Supertype_ICRC1_Actor"><span class="keyword">type </span><span class="type">Supertype_ICRC1_Actor</span> = <span class="type">TokenSpecific.ICRC1.Supertype.Actor</span></h4><p><p><strong>Externally accessible ICRC1 token-canister supertype actor included for consistency.</strong></p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.SupportedToken"><span class="keyword">type </span><span class="type">SupportedToken</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt; = {#ICP : <span class="type">T1</span>; #ICP_nns : <span class="type">T1</span>; #ICRC1_ExampleToken : <span class="type">T2</span>; #ICRC1_ExampleToken2 : <span class="type">T2</span>}</h4><p><p><strong>Some type that makes the rest possible.</strong><br/>    Entries of this variant are all the token-ledger canisters this invoice canister supports. The generic arguments<br/>    are the distinct types each token uses and may be shared: additional ICRC1 standard tokens can reuse the generic<br/>    type T2. Adding or removing an entry will trigger the VSCode Motoko extension to indicate all the methods' switches'<br/>    cases that need to be edited to add or remove support for a particular ICP or ICRC1 standard token (in this file,<br/>    it is only the methods below this declaration; there are several in <code>Invoice.mo</code> as well).</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.UnitType"><span class="keyword">type </span><span class="type">UnitType</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;(), ()&gt;</h4><p><p>Corresponding supported token &quot;base&quot; types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Amount"><span class="keyword">type </span><span class="type">Amount</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.Tokens</span>, <span class="type">TokenSpecific.ICRC1.Tokens</span>&gt;</h4><p><p>Corresponding supported token type canister expected amount types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Address"><span class="keyword">type </span><span class="type">Address</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.AccountIdentifier</span>, <span class="type">TokenSpecific.ICRC1.Account</span>&gt;</h4><p><p>Corresponding supported token type canister expected address types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.TransferArgs"><span class="keyword">type </span><span class="type">TransferArgs</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.TransferArgs</span>, <span class="type">TokenSpecific.ICRC1.TransferArgs</span>&gt;</h4><p><p>Corresponding supported token type canister expected TransferArgs types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.TransferResult"><span class="keyword">type </span><span class="type">TransferResult</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.TransferResult</span>, <span class="type">TokenSpecific.ICRC1.TransferResult</span>&gt;</h4><p><p>Corresponding supported token type canister expected TransferResult types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.TransferSuccess"><span class="keyword">type </span><span class="type">TransferSuccess</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.BlockIndex</span>, <span class="type">TokenSpecific.ICRC1.TxIndex</span>&gt;</h4><p><p>Corresponding supported token type canister expected TransferSuccess types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.TransferErr"><span class="keyword">type </span><span class="type">TransferErr</span> = <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">TokenSpecific.ICP.TransferError</span>, <span class="type">TokenSpecific.ICRC1.TransferError</span>&gt;</h4><p><p>Corresponding supported token type canister expected TransferErr types.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.RecipientAddress"><span class="keyword">type </span><span class="type">RecipientAddress</span> = {#HumanReadable : <span class="type">Text</span>; #CanisterExpected : <a href="#type.Address"><span class="type">Address</span></a>}</h4><p><p><strong>Sum type for converting between human parsable and canister expected address types.</strong></p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.TokenVerbose"><span class="keyword">type </span><span class="type">TokenVerbose</span> = { symbol : <span class="type">Text</span>; name : <span class="type">Text</span>; decimals : <span class="type">Int</span>; fee : <span class="type">Nat</span>; meta : ?{ Issuer : <span class="type">Text</span>; Url : <span class="type">Text</span> } }</h4><p><p><strong>Hard coded token's information record.</strong><br/>    At least the fee must be correctly defined for additional tokens in <code>getTokenVerbose</code> below.</p>
</p></div><div class="declaration"><h4 class="function" id="getTokenVerbose"><code><span class="keyword">public func </span><span class="fnname">getTokenVerbose</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="parameter">supportedToken</span> : <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;) : <a href="#type.TokenVerbose"><span class="type">TokenVerbose</span></a></code></h4><p><p><strong>Additional supported tokens **must</strong> at least have their correct transfer fee defined here.**</p>
</p></div><div class="declaration"><h4 class="function" id="getTransactionFee"><code><span class="keyword">public func </span><span class="fnname">getTransactionFee</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="parameter">supportedToken</span> : <a href="#type.SupportedToken"><span class="type">SupportedToken</span></a>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;) : <span class="type">Nat</span></code></h4><p><p><strong>Returns the transaction fee as immutably defined in the <code>getTokenVerbose</code> for the given token type.</strong></p>
</p></div><div class="declaration"><h4 class="function" id="unwrapTokenAmount"><code><span class="keyword">public func </span><span class="fnname">unwrapTokenAmount</span>(<span class="parameter">amount</span> : <a href="#type.Amount"><span class="type">Amount</span></a>) : (<a href="#type.UnitType"><span class="type">UnitType</span></a>, <span class="type">Nat</span>)</code></h4><p><p><strong>Returns the corresponding <code>UnitType</code> &amp; amount in <code>Nat</code> base units for the given <code>SupportedToken.Amount</code>.</strong></p>
</p></div><div class="declaration"><h4 class="function" id="wrapAsTokenAmount"><code><span class="keyword">public func </span><span class="fnname">wrapAsTokenAmount</span>(<span class="parameter">token</span> : <span class="type">SupportedToken.UnitType</span>, <span class="parameter">amount</span> : <span class="type">Nat</span>) : <span class="type">SupportedToken.Amount</span></code></h4><p><p><strong>Reforms the base unit amount into the given specific token's amount record type.</strong></p>
</p></div><div class="declaration"><h4 class="function" id="encodeAddress"><code><span class="keyword">public func </span><span class="fnname">encodeAddress</span>(<span class="parameter">a</span> : <a href="#type.Address"><span class="type">Address</span></a>) : <span class="type">Text</span></code></h4><p><p><strong>Encodes a given address into text **without</strong> validation.<strong><br/>    _For addresses computed by the invoice canister in a way **known</strong> to be rigorousily tested._</p>
</p></div><div class="declaration"><h4 class="function" id="encodeAddressOrUnitErr"><code><span class="keyword">public func </span><span class="fnname">encodeAddressOrUnitErr</span>(<span class="parameter">a</span> : <a href="#type.Address"><span class="type">Address</span></a>) : <span class="type">Result.Result</span>&lt;<span class="type">Text</span>, ()&gt;</code></h4><p><p><strong>Encodes a given address into text **with</strong> validation.<strong><br/>    _For addresses supplied by a caller that **are not</strong> necessarily known to be valid._</p>
</p></div><div class="declaration"><h4 class="function" id="getAddressOrUnitErr"><code><span class="keyword">public func </span><span class="fnname">getAddressOrUnitErr</span>(<span class="parameter">token</span> : <a href="#type.UnitType"><span class="type">UnitType</span></a>, <span class="parameter">destination</span> : <a href="#type.RecipientAddress"><span class="type">RecipientAddress</span></a>) : <span class="type">Result.Result</span>&lt;<a href="#type.Address"><span class="type">Address</span></a>, ()&gt;</code></h4><p><p><strong>Returns an address decoded from given text or returns a given address if valid.</strong><br/>    <strong>Validation occurs in either case.</strong> Also note in either case whether text or address is<br/>    given the correct matching token type must given as the passed <code>token</code> argument.<br/>    <em>For addresses supplied by a caller that <strong>are not</strong> necessarily known to be valid.</em></p>
</p></div><div class="declaration"><h4 class="function" id="getInvoiceSubaccountAddress"><code><span class="keyword">public func </span><span class="fnname">getInvoiceSubaccountAddress</span>() : <a href="#type.Address"><span class="type">Address</span></a></code></h4><p><p><strong>Returns the corresponding token address for an invoice subaccount.</strong></p>
</p></div><div class="declaration"><h4 class="function" id="getEncodedInvoiceSubaccountAddress"><code><span class="keyword">public func </span><span class="fnname">getEncodedInvoiceSubaccountAddress</span>() : <span class="type">Text</span></code></h4><p><p><strong>Returns the corresponding token address encoded as text of the invoice subaccount address<br/>    computed from the given invoice id, creator's principal and invoice canister id.</strong><br/>    <em>Specifically used when creating an invoice.</em></p>
</p></div><div class="declaration"><h4 class="function" id="getCreatorSubaccountAddress"><code><span class="keyword">public func </span><span class="fnname">getCreatorSubaccountAddress</span>() : <a href="#type.Address"><span class="type">Address</span></a></code></h4><p><p><strong>Returns the corresponding token address for an invoice creator's subaccount.</strong></p>
</p></div><div class="declaration"><h4 class="function" id="getTransferArgsFromInvoiceSubaccount"><code><span class="keyword">public func </span><span class="fnname">getTransferArgsFromInvoiceSubaccount</span>() : <a href="#type.TransferArgs"><span class="type">TransferArgs</span></a></code></h4><p><p><strong>Returns <code>TransferArgs</code> from invoice's subaccount to a specified destination address.</strong><br/>    <strong>Note!</strong> Fees must be subtracted <strong>before</strong> calling this method as <code>TransferArgs</code> can use their own Nat types.<br/>    <strong>Note!</strong> Validation of the input for the specified destination address must happen <em>before</em> calling this method.</p>
</p></div><div class="declaration"><h4 class="function" id="getTransferArgsFromCreatorSubaccount"><code><span class="keyword">public func </span><span class="fnname">getTransferArgsFromCreatorSubaccount</span>() : <a href="#type.TransferArgs"><span class="type">TransferArgs</span></a></code></h4><p><p><strong>Returns <code>TransferArgs</code> from invoice creator's subaccount to a specified destination address.</strong><br/>    <strong>Note!</strong> Fees must be subtracted <strong>before</strong> calling this method as <code>TransferArgs</code> can use their own Nat types.<br/>    <strong>Note!</strong> Validation of the input for the specified destination address must happen <em>before</em> calling this method.</p>
</p></div><div class="declaration"><h4 class="function" id="rewrapTransferResults"><code><span class="keyword">public func </span><span class="fnname">rewrapTransferResults</span>(<span class="parameter">sttransferResult</span> : <a href="#type.TransferResult"><span class="type">TransferResult</span></a>) : <span class="type">Result.Result</span>&lt;<a href="#type.TransferSuccess"><span class="type">TransferSuccess</span></a>, <a href="#type.TransferErr"><span class="type">TransferErr</span></a>&gt;</code></h4><p><p><strong>Rewraps result types returned from corresponding token canisters' transfer calls.</strong><br/>    To that expected by the invoice canister caller. Note that before they are returned<br/>    to the caller, if they are of type <code>#Err</code> they are set as the <code>#err</code><br/>    <code>SupportedTokenTransferErr</code> kind.</p>
</p></div><div class="declaration"><h4 class="function" id="getDefaultSubaccountAddress"><code><span class="keyword">public func </span><span class="fnname">getDefaultSubaccountAddress</span>(<span class="parameter">tokenType</span> : <span class="type">SupportedToken.UnitType</span>, <span class="parameter">p</span> : <span class="type">Principal</span>) : { asAddress : <span class="type">SupportedToken.Address</span>; asText : <span class="type">Text</span> }</code></h4><p><p><strong>Computes the default subaccount for the address type given by <code>tokenType</code> for the given principal.</strong></p>
</p></div></div></body></html>